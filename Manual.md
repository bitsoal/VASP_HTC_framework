##VASP HTC Framework  
Yang Tong 
bitsoal@gmail.com  
Department of Physics, National University of Singapore

Luo Yong Zheng  
luoyzh09@gmail.com  
Department of Physics, National University of Singapore

### This is a simple framework designed for high-throughput calculation based on VASP.
version: python2.7  
Package requirements: pymatgen

####How to run:
1. fill HTC_lib_path, cif_file_folder, cal_folder, HTC_calculation_setup_file in htc_main.py
2. write a file named, say HTC_calculation_setup according to HTC_manual.txt.
3. `python htc_main.py` OR `nohup python htc_main.py > log.txt 2>&1 &`

You may look through the htc example about WSe2 supercell under folder examples



###Terminologies we used
We adopt the terminologies below from pymatgen, atomate:
  
* firetask - A Firetask is an atomic computing job. For example:
  * copy files  
  * move files
  * remove files
  * prepare VASP input files based on pymatgen
  * modify INCAR
  * modify KPOINTS
  * submit VASP jobs
  * kill VASP jobs
  * fix some common errors, i.e. ionic divergence, electronic divergence, positive energy.
* firework - A firework is a series of firetaks. Normally, it is composed of three types of firetasks w.r.t the VASP calculation
  * pre-process: setup VASP input files.
      * They can be copied or moved from previous step calucations.
      * They can be generated by pymatgen from scratch.
      * Once VASP input files are prepared via either ways above, they need to be modified so that they are finally appropriate for the target VASP calculation.
  * post-process: actions made after the VASP calculations. Note that currently, this section is not ready.
  * job-management: related to job submissions, queries or terminations. 
  * **Note that in fact, job submissions queries, or terminations will be realized via signal files (see below). The main jobs for a firework are the pre-process and post-process.**
* workflow - A workflow is a set of fireworks with dependencies between them. For example: 
  * CHGCAR from scf will be required for DOS or band structure calculations.
  * It is common that the addition of dipole corrections likely leads to the electronic divergence. So CHGCAR may required from a previous calculation without dipole correction.
  * For HSE06 calculations, PBE WAVECAR are required.

You may refer to [atomate](https://hackingmaterials.github.io/atomate/creating_workflows.html#creating-workflows) for more detailed definitions.

###organizations
**Let's assume the HTC workflow setup is saved into a file named HTC\_calculation\_setup and besides cif files, this is the only file you need to specify.What follows is how to setup a workflow by composing HTC\_calculation\_setup**

* HTC_calculation_setup consists of a set of blocks, namely fireworks
* Every firework starts from the line which begins with `**start`, and ends up with the line which begins with `**end`
* In a firework
  * pre-processes and post-processes are defined in a key-value manner with the equal sign `=` linking them. **There is an exception that inside a firework, there is a sub-block. This sub-block starts from the line which begins with `\*begin(add_new_incar_tags)` and it ends with the line which begins with `\*end(add_new_incar_tags)`. In this sub-block, you can overwrite INCAR tags or add new INCAR tags just like you are writing INCAR.**
  * In addition, job submissions, queries or terminations will also need to be specified in a key-value manner.
  * Note that in the first firework, some job management tags must be set and these setting will be used for the whole workflow:
     * the command to query a job status from a queue system.
     * the command to kill a running job
     * the file which hosts the queue id, say job_id
     * the regular expression to parse the queue id from file job_id
     * the new name of vasp.out.
         * if the job submission cmd in the submission script looks like `mpirun -n 16 vasp_std > out`, then new name of file vasp.out is out
         * if the job submission cmd in the submission script looks like `mpirun -n 16 vasp_std`, then file vasp.out isn't renamed.
     * the prefix and suffix of the stdout file generated by the queue system after the calculation.
     * the prefix and suffix of the stderr file generated by the queue system after the calculation.
     * forece\_gamma: if the kpoints are forced to be gamma-centered.
     * 2d_system: for 2D systems, KPOINTS will be modified so that K\_z is zero for all kpoints.





<br><br>
###Tag list - below are tags that can be set in HTC\_calculation\_setup
----------------------
![Alt Text](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/VASP_input_file_preparations.png)


- **step\_no** (integer), **required for every firework**.  
for the n-th firework, step\_no must be n.

------------------------------------------

- **cal\_name** (str), **required for every firework**.  
numbers, alphabets and underscores are valid symbols. *Note that the space between word will be replaced with an underscore.*  
Together with step\_no, a folder named `step_ + step_no + _ + cal_name` will be created. Under this folder, the VASP calculation will be carried out. e.g. if step\_no=4, cal\_name=band str, then the folder name is `step_4_band_str`

-----------------------------

- **copy\_from\_prev\_cal**, optional.  
**This is one way to set up VASP input files.**  
the right hand side of `=` should one or more than one files that will copied from the previous calculation.
If more than one files are specified, separate them with commas    
If copy\_which\_step is not set, the previous calculation means the 'nearest' previous calculation.  
Default: empty

------------------------------

- **move\_from\_prev\_cal**, optional.  
same as copy\_from\_prev\_cal, but those specified files will be moved instead of being copied from the firework specified by copy\_which\_step.  
Default: empty

----------------------

- **contcar\_to\_poscar** (bool), optional.  
Whether to copy the POSCAR from the firework specified by copy\_which\_step and rename it as POSCAR.  
If this tag is `Yes`, the CONTCAR from the previous calculation will be implicitly copied and renamed as POSCAR, even though CONTCAR is not in the file list specified by tags copy\_from\_prev\_cal or move\_from\_prev\_cal  
Default: `No`

--------------------------------

- **copy\_which\_step** (integer), optional.  
This will specify where to copy the files listed in copy\_from\_prev\_cal.  
Default: the step\_no of the 'nearest' previous calculation.

---------------------------------

- **remove\_after\_cal**, optional.  
*This tag currently is not available*  
the right hand side of `=` should one or more than one files that will removed after the calculation defined in this firework.  
While using this tag, make sure that those specified files will not be needed for later calculations.    
Default: empty

----------------------------------------

- **extra\_copy**, optional.  
This tag allows you to copy files which are not in the previous firework folders.  
If more than one files are specified, separate them with commas.  
**The copy action defined by this tag is carried out earlier than the copy/move actions defined by copy\_from\_prev\_cal, move\_from\_prev\_cal. So it is before the modifications on vasp input files.**  
**Note that the absolute path should be given.**

------------------------------------
	
- **final\_extra\_copy**, optional.  
This tag allows you to copy files which are not in the previous firework folders.  
If more than one files are specified, separate them with commas.  
**The copy action defined by this tag is carried out AFTER the modifications on vasp input files.**   
**Note that the absolute path should be given.**    
  - ***Why this tag?***  
 This tag is useful especially for the first firework. By default, the vasp input files for the first firework are generated by pymatgen.io.vasp.sets.MPRelaxSet. Then you can adjust the input files through tags like comment\_incar\_tags, remove\_incar\_tags, or add\_new\_incar\_tags sub-blocks, denser\_kpoints. But you may sometimes only need POSCAR generated by pymatgen based on the given cif file and want to provide INCAR, KPOINTS, or POTCAR yourself.  

-------------------------------

- **comment\_incar\_tags**, optional.  
comment VASP INCAR tags  
If multiple tags need to be commented, separate them with commas.    
Default: empty

--------------------------

- **remove\_incar\_tags**, optional.  
remove VASP INCAR tags.  
If multiple INCAR tags need to be removed, separate them with commas.  
Default: empty

-------------------------------

- **add\_new\_incar\_tags** sub-block, optional
  - start from the line which starts with `*begin(add_new_incar_tags)`; end up with the line which starts with `*end(add_new_incar_tags)`
  - In between the starting line and ending line, just specify INCAR tags as if you are writing INCAR:
     - If an INCAR tag is already in the old INCAR, this tag will be overwritten.
     - If an INCAR tag is not in the old INCAR, this tag will be added.

--------------------------------------
- **kpoints\_type**, **case sensitive**, required for every firework  
options - MPRelaxSet, MPStaticSet, MPNonSCFSet\_line, MPNonSCFSet\_uniform, Line-mode:
  - MPRelaxSet: The KPOINTS generated by pymatgen.io.vasp.sets.MPRelaxSet
  - MPStaticSet: The KPOINTS generated by pymatgen.io.vasp.sets.MPStaticSet
  - MPNonSCFSet\_line: The KPOINTS generated by pymatgen.io.vasp.sets.MPNonSCFSet in the line mode --> band structure
  - MPNonSCFSet\_uniform: The KPOINTS generated by pymatgen.io.vasp.sets.MPNonSCFSet in the uniform mode --> In pymatgen, this type of KPOINTS is for DOS calculations.
  - Line-modeï¼š The KPOINTS in the line mode is written in the reciprocal coordinates for the band structure calculations. The high-symmetry kpoints is decided by pymatgen.symmetry.bandstructure.HighSymmKpath


This tag has two functions:
  
   1. After extra\_copy, copy\_from\_prev\_cal or move\_from\_prev\_cal, if there is still no file KPOINTS under the current firework folder, KPOINTS will be created according to kpoints\_type. *Note for the first firework, KPOINTS by default is generated by pymatgen.io.vasp.sets.MPRelaxSet and in this case, this function is deactivated. If you want to overwrite KPOINTS for the first firework, you may copy KPOINTS somewhere via tag final\_extra\_copy.*  
   2. If tag 2d\_system is `Yes`, the KPOINTS will be modified so that K\_z is zero for all kpoints. *Note that this function will be only invoked if KPOINTS under the current firework folder is created by function. If KPOINTS is created by copying or moving to the current firework folder, KPOINTS is then assumed to have zero K\_z for all kpoints.*     

--------------------------------------

- **denser\_kpoints** (float), optional.  
This tag is only valid for the KPOINTS generated at kpoints\_type = MPRelaxSet, MPStaticSet.  
Suppose the divisions in the reciprocal space are nk_x, nk_y, nk_z, if it is not 1, say float\_no, then the new divsions are `int(nk_x*float_no), int(nk_y*float_no), int(nk_z*float_no)`  
Default: 1

---------------------------------------------------------
- **reciprocal\_density** (integer), optional.  
This tag is only valid at kpoints\_type=MPNonSCFSet\_uniform  
Default: 1000 <--- the value adopted by atomate's firework NonSCFFW

-----------------------------------------------------------------------
- **kpoints\_line\_density** (integer), optional.  
This tag is only valid at kpoints_type=MPNonSCFSet\_line  
Default: 40 <-- the default value for atomate's firework NonSCFFW is 20

---------------------------------
	
- **intersections** (integer), optional.  
This tag is only valid at kpoints_type=Line-mode.  
This number is the number of equally spaced kpoints between the starting and ending kpoints of every segment of the overall kpath, inclusive of the starting and ending kpoints.  
Default: 20

-----------------------------
- **force\_gamma**, optional.  
This tag can be set only in the first firework and this setting will be applied to the whole workflow.
  - `Yes`: force the kpoints to be gamma-cented.
  - `No`: no such constraint.  
  - Default: `No`

-----------------
- **2d\_system**, optional  
**This tag can be set only in the first firework and this setting will be applied to the whole workflow.**
  - `Yes`: modify kpoints such that K\_z is zero for all kpoints.
  - `No`: no such modification on kpoints.
  - Default: `No`
 
----------------------------------
	
- **sort\_structure**, optional.  
**This tag is only valid for the first firework.**
  - `Yes`: Sort sites by the electronegativity of the atomic species.
  - `No`: After pymatgen.io.vasp.sets.MPRelaxSet writes the vasp input files for the first firework, POSCAR will be overwritten by copying the given structure to the current firework folder. Note `No` can be set only when the structure is given in the format of POSCAR, not cif.
  - Default: `Yes`

***Why we need this tag?***  
In some cases, the atomic sites may be ordered carefully for some specific purposes. So you may not want to change the atomic sites by pymatgen

-----------------------------------------
####Below are tags related to job managements
-----------------------

- **job\_submission\_script**, **required for every firework**.  
**Note that the absolute path will be used.**

-------------------------------------------------


- **job\_submission\_command**, **required for every firework**.  
e.g. On LSF queue system, suppose the job submission script refered by job\_submission\_script tag is called `vasp.lsf` and this tag can be `bsub < vasp.lsf > job_id`, where `job_id` will store the queue id and will be the value of tag where\_to\_parse\_queue\_id

--------------------------------

- **where\_to\_parse\_queue\_id**, **required only for the first firework**.  
a file from which the queue id will be parsed.  
e.g. If the job submission cmd is `bsub < vasp.lsf > job_id`, it is `job_id`

---------------------

- **re\_to\_parse\_queue\_id**, **required only for the first firework**.  
The regular expression pattern passed to python re.findall to parse queue id from the file specified by where\_to\_parse\_queue\_id.  
Just make sure this regular expression is well designed so that no other string in the file where\_to\_parse\_queue\_id can be matched.

----------------------------------

- **job\_query\_command**, **required only for the first firework**.  
For LSF queue system, it is `bjobs@-w` **where @ is used to denote space**.
For PBS queue system, it is `qstat`

---------------------------------------------------------

- **job\_killing\_command**, **required only for the first firework**.
For LSF queue system, it is `bkill`.
For PBS queue system, it is `qdel`

--------------------------

- **queue\_stdout\_file\_prefix**, **queue\_stdout\_file\_suffix**, **queue\_stderr\_file\_prefix**, **queue\_stderr\_file\_suffix**, **Required for the first firework**.  
Normally, when the calculation is done, the queue system will generate two files reporting errors and summarizing this work, respectively. Let's denote them as stdout, stderr.  
The two files are useful for their presence indicates that the job is done. If no error is detected for this step, the post-process will proceed and afterwards, the next firework will be carried out. 
 
     **These four tags are set to search for stdout and stderr files.**  
     **Note that you need to specify at least one of the four tags:**  
       - Sometimes the queue stdout and stderr files will join together, giving a single file. In this case, this single file is the target file. You can set its prefix or suffix using either (queue\_stdout\_file\_prefix, queue\_stdout\_file\_suffix) or (queue\_stderr\_file\_prefix, queue\_stderr\_file\_suffix) pair.
       - For either queue stdout or stderr files, it may only have a fixed prefix or a fixed suffix. In this case, you just need to specify the fixed one for the queue file.
         - e.g. for lsf.o1234, just set queue_stdout_file_prefix = lsf.o
         - e.g. for 1234pbs.e, just set queue_stderr_file_suffix = pbs.e
      - **Just make sure the provided suffix or prefix can find the target file(s) stdout or stderr.** 

--------------------------
- **vasp.out**, **required only for the first firework**.  
e.g. If the vasp submission cmd is `mpirun -n 16 vasp_std > out`, then **vasp.out** is `out`  
e.g. If the vasp submission cmd is `mpirun -n 16 vasp_std`, then **vasp.out** is `vasp.out`


-------------
###Tag list ends here

<br>
<br>
<br>

##How to control job status
###We use signal files to control job submission, job termination, error detection and error correction

![Alt Text](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/signal_file_response.PNG)


When the workflow is running, some signal file will be present in every firework folder. The program will respond to these signal files as listed below:
  
- `__vis__`: The program will prepare the vasp input files according to the workflow. Once it is done, `__vis__` --> `__ready__`
- `__ready__`: The program will submit the job by using the command defined in the workflow. Once submitted, `__ready__` --> `__running__`
- `__prior_ready__`: The program will first submit the jobs with this signal file compared to those labeled by `__ready__`
- `__running__`: The program will check the errors on the fly, e.g. check the electronic divergence. If the errors are detected, `__running__` --> `__error__` and write the error type into `__error__`
- `__error__`: The program will kill the job. Once it is done, `__error__` --> `__killed__`
- `__killed__`: The program will try to fix the error. If successful, `__killed__` --> `__ready__`; otherwise `__killed__` --> `__manual__`
- queue system's `stdout` and `stderr`: The program will think the job is done and all error checkers will be called to check errors. If any errors are found, `__running__` --> `__error__`; Otherwise, `__running__` --> `__done__`
- `__manual__`: The program cannot fix the error and the error should be fixed manually.
- `__bad_termination_`: When the job fails due to the error `=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES` in file vasp.out **for the first time**, the program will **resubmit** the job automatically and create this signal file. When such error happens again, the presence of this signal file tells the program that this is the second time to encounter such error. In this case, the program cannot automatically handle this error anymore, `__killed__` --> `__manual__`.


**Note that when you manually fix an error or tune VASP input files under a filework folder, DO remove these signal tags so that the program has nothing to do with this firework folder. After modifications, you have two ways to bring it back to the program scope (_The second way is recommended_):**

- If you want to manually submit the job:
  - step I: remove OUTCAR, OSZICAR, vasp.out, queue stdout & stderr files.
  - step II: submit the job
  - step III: create the signal file `__running__`.
- If you want the program to do the job submission:
	- All you need to do is to create the signal file `__ready__`. In this case, the program will automatically remove OUTCAR, OSZICAR, vasp.out, queue stdout & stderr files before submitting this job.  



