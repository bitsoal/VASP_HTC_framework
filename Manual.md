## VASP HTC Framework  
Yang Tong   
bitsoal@gmail.com  
Department of Physics, National University of Singapore

Luo Yong Zheng  
luoyzh09@gmail.com  
Department of Physics, National University of Singapore

### This is a simple framework designed for high-throughput calculation based on VASP.
version: python2.7  
Package requirements: [pymatgen](http://pymatgen.org/index.html)

#### How to run:
1. specify `HTC_lib_path` at the beginning of htc_main.py, where `HTC_lib_path` is the absolute path of the directory containing this VASP HTC package.
2. Compose a setup file named `HTC_calculation_setup_file`. See below for the composition of `HTC_calculation_setup_file`
3. In the directory containing `HTC_calculation_setup_file`, execute `python htc_main.py` OR `nohup python htc_main.py > log.txt 2>&1 &` to start this HTC program.



### Terminologies we used
We adopt the terminologies below from pymatgen, atomate:
  
* firetask - A Firetask is an atomic computing job. For example:
  * copy, move, remove files  
  * prepare VASP input files based on pymatgen
  * modify INCAR
  * modify KPOINTS
  * modify POSCAR
  * submit VASP jobs
  * submit or kill VASP jobs
  * fix some common errors, i.e. ionic divergence, electronic divergence, positive energy.
* firework - A firework is a series of firetaks. Normally, it is composed of three types of firetasks w.r.t the VASP calculation
  * pre-process: setup VASP input files.
      * They can be copied or moved from previous step calucations.
      * They can be generated by pymatgen from scratch.
      * Once VASP input files are prepared via either ways above, they need to be modified so that they are finally appropriate for the target VASP calculation.
  * post-process: actions made after the VASP calculations. *Note that currently, this section is not ready.*
  * job-management: related to job submissions, queries or terminations. **Note that in fact, job submissions, job status queries, or jobs terminations will be realized via signal files (see below). The main jobs for a firework are the pre-process and post-process.**
* workflow - A workflow is a set of fireworks with dependencies between them. For example: 
  * CHGCAR from scf will be required for DOS or band structure calculations.
  * It is common that including dipole corrections likely leads to the electronic divergence. So CHGCAR may be required from a previous calculation without dipole corrections.
  * For [HSE06 calculations](https://cms.mpi.univie.ac.at/vasp/vasp/Typical_hybrid_functional_Hartree_Fock_calculations.html), a preconverged PBE WAVECAR is a good starting point.

You may refer to [atomate](https://hackingmaterials.github.io/atomate/creating_workflows.html#creating-workflows) for more detailed definitions.

### organizations
**Let's assume the HTC workflow setup is saved into a file named HTC\_calculation\_setup and besides cif files, this is the only file you need to specify.What follows is how to setup a workflow by composing HTC\_calculation\_setup**

* `HTC_calculation_setup` consists of a set of blocks, namely fireworks
* Every firework starts from the line which begins with `**start`, and ends up with the line which begins with `**end`
* In a firework
  * pre-processes and post-processes are defined in a key-value manner with the equal sign `=` linking them. **There is an exception that inside a firework, there is a sub-block. This sub-block starts from the line which begins with `\*begin(add_new_incar_tags)` and it ends with the line which begins with `\*end(add_new_incar_tags)`. In this sub-block, you can overwrite INCAR tags or add new INCAR tags as you are writing INCAR.**
  * In addition, job submissions, job status queries or job terminations will also need to be specified in a key-value manner.
  * Note that in the first firework, some job management tags must be set and these setting will be used for the whole workflow:
     * the command to query a job status from a queue system.
     * the command to kill a running job
     * the file which hosts the queue id, say job_id
     * the regular expression to parse the queue id from file job_id using python `re.findall()`
     * tag **vasp.out**.
         * if the job submission cmd in the submission script looks like `mpirun -n 16 vasp_std > out`, then `vasp.out=out`
         * if the job submission cmd in the submission script looks like `mpirun -n 16 vasp_std`, then file vasp.out isn't renamed. So `vasp.out=vasp.out`
     * the prefix and suffix of the stdout file generated by the queue system after the calculation.
     * the prefix and suffix of the stderr file generated by the queue system after the calculation.
     * tag **forece_gamma**: if the kpoints are forced to be gamma-centered.
     * tag **2d_system**: for 2D systems, KPOINTS will be modified so that K\_z is zero for all kpoints.
     * tag **sort_structure**: Whether sort structure or not beforing write POSCAR by the electronegativity of the species





<br><br>
### Tag list - below are tags that can be set in HTC\_calculation\_setup
#### (Note that for boolean data type, we use 'Yes' and 'No')
----------------------
![Alt Text](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/VASP_input_file_preparations.png)


- **structure\_folder** (str), **required for the first firework**  
*The absolute path* of the directory containing to-be-calculated structures. Those to-be-calculated structures could be in the cif format, the VASP POSCAR format or other formats that are supported by `pymatgen.Structure.from_file`.

----------------------

- **cal\_folder** (str), optional for the first firework  
*The absolute path* of the calculation folder. Under this folder, a sub-folder will be created for a to-be-calculated structure. A series of sub-sub-folder will subsequently created for a sequence of VASP calculations.  
Default: `cal_folder= where the htc_main.py is called + \cal_folder`
  
-------------------

- **step\_no** (integer), **required for every firework**.  
start from 1.  
for the n-th firework, step\_no must be n.

------------------------------------------

- **cal\_name** (str), **required for every firework**.  
numbers, alphabets and underscores are valid symbols. *Note that the space between word will be replaced with an underscore.*  
Together with step\_no, a sub-folder named `step_ + step_no + _ + cal_name` will be created. Under this folder, the VASP calculation will be carried out. e.g. if `step_no=4`, `cal_name=band str`, then the folder name is `step_4_band_str`

-----------------------------

- **copy\_from\_prev\_cal**, optional.  
**This is one way to set up VASP input files.**  
the right hand side of `=` should one or more than one files that will be copied from the previous calculation.
*If more than one files are specified, separate them with commas*    
If copy\_which\_step is not set, the previous calculation means the *nearest* previous calculation.  
Default: empty

------------------------------

- **move\_from\_prev\_cal**, optional.  
same as copy\_from\_prev\_cal, but those specified files will be moved instead of being copied from the previous firework specified by copy\_which\_step.  
If copy\_which\_step is not set, the previous firework is the *nearest* previous firework.  
Default: empty

----------------------

- **contcar\_to\_poscar** (bool), optional.  
Whether to copy the POSCAR from the firework specified by copy\_which\_step and rename it as POSCAR.  
If this tag is `Yes`, the CONTCAR from the previous calculation will be *implicitly* copied and renamed as POSCAR, even though CONTCAR is not in the file list specified by tags copy\_from\_prev\_cal or move\_from\_prev\_cal  
Default: `No`

--------------------------------

- **copy\_which\_step** (integer), optional.  
This will specify where to copy the files listed in copy\_from\_prev\_cal or move the files listed in move\_from\_prev\_cal.  
Default: the step\_no of the *nearest* previous calculation.

---------------------------------

- **remove\_after\_cal**, optional.  
*This tag currently is not available*  
the right hand side of `=` should one or more than one files that will removed after the calculation defined in this firework.  
*While using this tag, make sure that those specified files will not be needed for later calculations.*    
Default: empty

----------------------------------------

- **extra\_copy**, optional.  
**This tag allows you to prepare VASP input files.**  
This tag allows you to copy files which are not in any previous firework folders.  
*If more than one files are specified, separate them with commas.*  
**The copy action defined by this tag is carried out earlier than the copy/move actions defined by copy\_from\_prev\_cal, move\_from\_prev\_cal. So it is before the modifications on vasp input files.**  
**Note that the absolute path should be provided.**

------------------------------------
	
- **final\_extra\_copy**, optional.  
This tag allows you to copy files which are not in any previous firework folders.  
*If more than one files are specified, separate them with commas.*  
**The copy action defined by this tag is carried out AFTER the modifications on VASP input files.**   
**Note that the absolute path should be provided.**    
  

-------------------------------

- **comment\_incar\_tags**, optional.  
comment VASP INCAR tags  
*If multiple tags need to be commented, separate them with commas.*  
**It doesn't make sense that you comment an INCAR tag using `comment_incar_tags` while resetting it in `add_new_incar_tags` sub-block simultaneously. If such a contradiction takes place, an error will be incurred.**    
Default: empty

--------------------------

- **remove\_incar\_tags**, optional.  
remove VASP INCAR tags.  
If multiple INCAR tags need to be removed, separate them with commas.  
**It doesn't make sense that you comment an INCAR tag using `remove_incar_tags` while resetting it in `add_new_incar_tags` sub-block simultaneously. If such a contradiction takes place, an error will be incurred.**  
Default: empty

-------------------------------

- **add\_new\_incar\_tags** sub-block, optional
  - start from the line which starts with `*begin(add_new_incar_tags)`; It ends up with the line which starts with `*end(add_new_incar_tags)`
  - In between the starting line and ending line, just specify INCAR tags as if you are writing INCAR:
     - If an INCAR tag is already in the old INCAR, this tag will be overwritten.
     - If an INCAR tag is not in the old INCAR, this tag will be added.  
       
**Note that in this sub-block, the multiple pairs of tag-values separated by `;` in a line is not supported. In this case, only the first pair of tag-value will be parsed as a new INCAR tag, and the value is what is in between the first `=` and the second `=`. This may incur unpredictable errors**  

**It doesn't make sense that you reset an INCAR tag in `add_new_incar_tags` sub-block while simultaneously trying to comment or remove this INCAR tag using `comment_incar_tags` or `remove_incar_tags`. If such a contradiction takes place, an error will be incurred.**

--------------------------------------
- **kpoints\_type**, **case sensitive**, **required for every firework**  
options - MPRelaxSet, MPStaticSet, MPNonSCFSet\_line, MPNonSCFSet\_uniform, Line-mode:
  - MPRelaxSet: The KPOINTS generated by pymatgen.io.vasp.sets.MPRelaxSet
  - MPStaticSet: The KPOINTS generated by pymatgen.io.vasp.sets.MPStaticSet
  - MPNonSCFSet\_line: The KPOINTS generated by pymatgen.io.vasp.sets.MPNonSCFSet in the line mode --> In pymatgen, this type of KPOINTS is for band structure calculations
  - MPNonSCFSet\_uniform: The KPOINTS generated by pymatgen.io.vasp.sets.MPNonSCFSet in the uniform mode --> In pymatgen, this type of KPOINTS is for DOS calculations.
  - Line-modeï¼š The KPOINTS in the line mode is written in the reciprocal coordinates for the band structure calculations. The high-symmetry kpoints is decided by [pymatgen.symmetry.bandstructure.HighSymmKpath](http://pymatgen.org/_modules/pymatgen/symmetry/bandstructure.html)


This tag has three functions:
  
   1. After extra\_copy, copy\_from\_prev\_cal or move\_from\_prev\_cal, if there is still no file KPOINTS under the current firework folder, KPOINTS will be created according to kpoints\_type.   
   2. If tag `2d_system` is `Yes`, the KPOINTS will be modified so that K\_z is zero for all kpoints. *Note that this function will be only invoked if KPOINTS under the current firework folder is created by function. If KPOINTS is created by copying or moving to the current firework folder, KPOINTS is then assumed to have zero K\_z for all kpoints.*  
   3. Tag `denser_kpoints` is only valid for the KPOINTS generated at kpoints\_type = MPRelaxSet, MPStaticSet.    

--------------------------------------

- **denser\_kpoints** (three float numbers), optional.  
This tag is only valid for the KPOINTS generated at kpoints\_type = MPRelaxSet, MPStaticSet.  
Suppose the divisions in the reciprocal space are nk_x, nk_y, nk_z and `denser_kpoints` is set to `mx, my, mz`, then the new divsions are `int(nk_x*mx), int(nk_y*my), int(nk_z*mz)`  
*Separate the three numbers with commas.*  
Default: `1, 1, 1`

---------------------------------------------------------
- **reciprocal\_density** (integer), optional.  
This tag is only valid at kpoints\_type=MPNonSCFSet\_uniform  
Default: `1000` <--- the value adopted by atomate's firework NonSCFFW

-----------------------------------------------------------------------
- **kpoints\_line\_density** (integer), optional.  
This tag is only valid at kpoints_type=MPNonSCFSet\_line  
Default: `40` <-- the default value for atomate's firework NonSCFFW is 20

---------------------------------
	
- **intersections** (integer), optional.  
This tag is only valid at kpoints_type=Line-mode.  
**intersections** is the number of equally spaced kpoints between the starting and ending kpoints of every segment of the overall kpath, inclusive of the starting and ending kpoints.  
Default: `20`

-----------------------------
- **force\_gamma**, optional.  
This tag can be set only in the first firework and *this setting will be applied to the whole workflow.*
  - `Yes`: force the kpoints to be gamma-cented.
  - `No`: no such kind of constraint.  
  - Default: `No`

-----------------
- **2d\_system**, optional  
**This tag can be set only in the first firework and this setting will be applied to the whole workflow.**
  - `Yes`: modify kpoints such that K\_z is zero for all kpoints.
  - `No`: no such modification on kpoints.
  - Default: `No`
 
----------------------------------
	
- **sort\_structure**, **optional for the first firework**.  
**This tag is activated once POSCAR is written for any firework.**
  - `Yes`: Sort sites by the electronegativity of the atomic species using [`pymatgen.Structure.get_sorted_structure`](http://pymatgen.org/_modules/pymatgen/core/structure.html).
  - `No`: If the given structure is POSCAR-formated, just copy the structure and rename it as POSCAR; If not, write POSCAR using `pymatgen.Structure`
  - Default: `Yes`  


***Why do we need this tag?***
  
  * In some cases, the atomic sites may be ordered carefully for some specific purposes. So you may not want to change the order of atoms by pymatgen
  * The `Yes` state of this tag aims to deal with the given structures whose atoms are not grouped by atomic species. For example, the atoms of the given MoS2 may be arranged like `S  Mo  S` instead of `S S  Mo` or `Mo S S`. Such non-grouped atom arrangements may happen if the to-be-calculated structures are outputs of pymatgen and before exporting from pymatgen, `get_sorted_structure` has not been called to group atoms. In case of non-grouped atomic arrangements, `sort_structure` defaults to `Yes`
  * The `No` state of this tag can facilitate [split-mode CALYPSO](http://www.calypso.cn/) for structure predictions. By applying the particle swarm optimization method, CALYPSO generates certain number of to-be-relaxed structures. *If CALYPSO works in the split mode, users should **manually** relax these structures.* These structures are POSCAR-formated. In order to make those POSCARs valid for both VASP 4 and VASP 5, the line listing atomic species is missing, but `pymatgen.Structure` cannot correctly parse such kind of POSCAR, let alone create correct POSCARs. So we provide this tag `sort_structure` whose `No` mode allows POSCAR to be created by just copying and renaming. With this `No` mode, this VASP HTC framework can be utilized to automatically relax structures predicted by CALYPSO. *Note that since `pymatgen` cannot write correct POTCAR due to the absence of atomic species line in CALYPSO-generated POSCARs, `POTCAR` should be copied from somewhere. This can be realized via tag `extra_copy` or `final_extra_copy`.*   

***The creation of POSCAR:***  
*For the second or later fireworks, POSCAR can be inherited from previous calculations, while this is not the case for the first firework. By default, for the first firework, the program will retrieve the structure under the folder which is specified by variable `cif_file_folder` in the script `htc_main.py` and where all to-be-calculated structures are stored in the form of cif, POSCAR or others that are supported by `pymatgen.Structure`. Once POSCAR is created according to tag `sort_structure` for the first firework, other VASP input files can be created accordingly and calculations therefore proceed. Of course, you may use tag `user_defined_cmd` to overwrite POSCAR, say cleave surfaces, which is why we let the firetasks defined by `user_defined_cmd` run before the creation of other VASP input files.*

-------------------------------------------
**user\_defined\_cmd**, optional,  
This tag allows users to execute a series of commands to perform user-defined firetasks, say cleave a surface from a bulk structure optimized in the previous firework, introduce dopants/defects *et. al.*  
*If there are multiple commands, separate them with commas.*  
e.g. `user_defined_cmd = date@>>__test_file__, echo@'test user_defined_cmd tag'@>>__test_file__`  
**Note that for this tag, we use `@` to denote a white space**  
**By default, the commands will be executed in the current firework folder. You can put your commands in a bash script and before executing them, switch to other folders. If your firetasks involve modifications of VASP input files, we suggest you to make a sub-folder under the current firework folder. Just copy required files into this sub-folder, carry out your firetasks and copy results back, e.g. new POSCAR**  
Default: empty

------------------------

**final\_user\_defined\_cmd**, optional,  
This tag allows users to execute a series of commands to perform user-defined firetasks.  
*If there are multiple commands, separate them with commas.*  
e.g. `final_user_defined_cmd = date@>>__test_file__, echo@'test final_user_defined_cmd tag'@>>__test_file__`  
**Note that for this tag, we use `@` to denote a white space**  
**By default, the commands will be executed in the current firework folder. You can put your commands in a bash script so that before executing them, you can switch to other folders. If your firetasks involve modifications of VASP input files, we suggest you to make a sub-folder under the current firework folder. Just copy required files into this sub-folder, carry out your firetasks and copy results back**  
Default: empty

------------------------------------

**user\_defined\_postprocess\_cmd**, optional,  
This tag allows users to execute a series of commands to perform user-defined firetasks for post-process. *This tag is currently not available*  
*If there are multiple commands, separate them with commas.*  
e.g. `user_defined_postprocess_cmd = date@>>__test_file__, echo@'test user_defined_postprocess_cmd tag'@>>__test_file__`  
**Note that for this tag, we use `@` to denote a white space**  
**By default, the commands will be executed in the current firework folder. You can put your commands in a bash script so that before executing them, you can switch to other folders. If your firetasks involve modifications of VASP output files, we suggest you to make a sub-folder under the current firework folder in order to avoid damaging VASP output files. Just copy required files into this sub-folder, carry out your firetasks (and copy results back to the current firework folder)**  
Default: empty

-----------------------------------------
#### Below are tags related to job managements
-----------------------

- **job\_submission\_script**, **required for every firework**.  
**Note that the absolute path should be used.**

-------------------------------------------------


- **job\_submission\_command**, **required for every firework**.  
e.g. On LSF queue system, suppose the job submission script refered by job\_submission\_script tag is called `vasp.lsf` and this tag can be `bsub < vasp.lsf > job_id`, where `job_id` will store the queue id and will be the value of tag where\_to\_parse\_queue\_id

--------------------------------

- **max\_running\_job** (integer), optional for the first firework  
The maximum number of running/pending jobs in queue. Note that this number is the **total** number of jobs in queue. For example, if `max_running_job=10` and there are already 3 running/pending jobs in queue, then 7 jobs at most can be submitted.  
Default: `max_running_job=30`

--------------------

- **where\_to\_parse\_queue\_id**, **required only for the first firework**.  
a file from which the queue id will be parsed.  
e.g. If the job submission cmd is `bsub < vasp.lsf > job_id`, then `where_to_parse_queue_id=job_id`

---------------------

- **re\_to\_parse\_queue\_id**, **required only for the first firework**.  
The regular expression pattern passed to python `re.findall` to parse queue id from the file specified by where\_to\_parse\_queue\_id.  
Just make sure this regular expression is well designed so that no other string in the file where\_to\_parse\_queue\_id can be matched.

----------------------------------

- **job\_query\_command**, **required only for the first firework**.      
For LSF queue system, it is `bjobs@-w` **where @ is used to denote a white space**.  
For PBS queue system, it is `qstat`

---------------------------------------------------------

- **job\_killing\_command**, **required only for the first firework**.  
For LSF queue system, it is `bkill`.    
For PBS queue system, it is `qdel`

--------------------------

- **queue\_stdout\_file\_prefix**, **queue\_stdout\_file\_suffix**, **queue\_stderr\_file\_prefix**, **queue\_stderr\_file\_suffix**, **Required for the first firework**.  
Normally, when the calculation is done, the queue system will generate two files reporting errors and summarizing this work, respectively. Let's denote them as stdout, stderr.  
The two files are useful for their presence indicates that the job is done. If no error is detected for this step, the post-process will proceed and afterwards, the next firework will be carried out. 
 
     **These four tags are set to search for stdout and stderr files.**  
     **Note that you need to specify at least one of the four tags:**  
       - Sometimes the queue stdout and stderr files will join together, giving a single file. In this case, this single file is the target file. You can set its prefix or suffix using either (queue\_stdout\_file\_prefix, queue\_stdout\_file\_suffix) or (queue\_stderr\_file\_prefix, queue\_stderr\_file\_suffix) pair.
       - For either queue stdout or stderr files, it may only have a fixed prefix or a fixed suffix. In this case, you just need to specify the fixed one for the queue file.
         - e.g. for lsf.o1234, just set queue_stdout_file_prefix = lsf.o
         - e.g. for 1234pbs.e, just set queue_stderr_file_suffix = pbs.e
      - **Just make sure the provided suffix or prefix can find the target file(s) stdout or stderr.** 

--------------------------
- **vasp.out**, **required only for the first firework**.  
e.g. If the vasp submission cmd is `mpirun -n 16 vasp_std > out`, then **vasp.out** is `out`  
e.g. If the vasp submission cmd is `mpirun -n 16 vasp_std`, then **vasp.out** is `vasp.out`



-------------
### Tag list ends here. You can find a template of `HTC_calculation_setup_file` under folder `Template`
-------------------------

### Below is a template of `HTC_calculation_setup_file` in which those tags are at least required. You can customize this template by adding new tags based on the properties in your interest:


<br>
<br>
<br>

## How to control job status
### We use signal files to control job submission, job termination, error detection and error correction

![Alt Text](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/signal_file_response.PNG)


When the workflow is running, some signal file will be present in every firework folder. The program will respond to these signal files as listed below:
  
- `__vis__`: The program will prepare the vasp input files according to the workflow. Once it is done, `__vis__` --> `__ready__`
- `__ready__`: The program will submit the job by using the command defined in the workflow. Once submitted, `__ready__` --> `__running__`
- `__prior_ready__`: The program will first submit the jobs with this signal file compared to those labeled by `__ready__`
- `__running__`: The program will check the errors on the fly, e.g. check the electronic divergence. If the errors are detected, `__running__` --> `__error__` and write the error type into `__error__`
- `__error__`: The program will kill the job. Once it is done, `__error__` --> `__killed__`
- `__killed__`: The program will try to fix the error. If successful, `__killed__` --> `__ready__`; otherwise `__killed__` --> `__manual__`
- queue system's `stdout` and `stderr`: The program will think the job is done and all error checkers will be called to check errors. If any errors are found, `__running__` --> `__error__`; Otherwise, `__running__` --> `__done__`
- `__manual__`: The program cannot fix the error and the error should be fixed manually.
- `__bad_termination_`: When the job fails due to the error `=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES` in file vasp.out **for the first time**, the program will **resubmit** the job automatically and create this signal file. When such error happens again, the presence of this signal file tells the program that this is the second time to encounter such error. In this case, the program cannot automatically handle this error anymore, `__killed__` --> `__manual__`.


**Note that when you manually fix an error or tune VASP input files under a filework folder, DO remove these signal tags so that the program has nothing to do with this firework folder. After modifications, you have two ways to bring it back to the program scope (_The second way is recommended_):**

- If you want to manually submit the job:
  - step I: remove OUTCAR, OSZICAR, vasp.out, queue stdout & stderr files.
  - step II: submit the job
  - step III: create the signal file `__running__`.
- If you want the program to do the job submission:
	- All you need to do is to create the signal file `__ready__`. In this case, the program will automatically remove OUTCAR, OSZICAR, vasp.out, queue stdout & stderr files before submitting this job.  


### How to stop the program.
You can stop this program by creating a file named `__stop__` under the same directory where `python htc_main.py` or `nohup python htc_main.py 2>1&` was executed to start this program.



