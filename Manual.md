## VASP HTC Framework  
Yang Tong   
bitsoal@gmail.com;yangtong@u.nus.edu  
Department of Physics, National University of Singapore


### This is a simple framework designed for high-throughput calculation based on VASP.
Package requirements: [pymatgen](http://pymatgen.org/index.html)  
`Mater` Branch: stable and work well on python2.7  
`upgrade_to_python_3` Branch: we are working on upgrading to python3

#### How to run:
1. specify `HTC_lib_path` at the beginning of htc_main.py, where `HTC_lib_path` is the absolute path to this VASP HTC package.
2. Write up a setup file named `HTC_calculation_setup_file`. See below for the composition of `HTC_calculation_setup_file`
3. In the directory containing `HTC_calculation_setup_file`, execute `python htc_main.py` OR `nohup python htc_main.py > log.txt 2>&1 &` to start this HTC program.

</br>

------------------------------------------
## The calculations listed below are already available:  
* **Structural relaxations**
* **Self-consistent calculations**
* **Density of states**
* **LDA+U calculations**
* **Band structure (KPOINTS can be automatically created for either PBE and HSE06)**
* **Partial charge around CBM and VBM**
* **Bader charge calculation**
* **Other calculations that can be setup by simply changing INCAR (e.g. phonon dispersions)**
* **Sub-folder calculations (for e.g. lattice constant optimization)**
* **Can facilitate split-mode [CALYPSO](http://www.calypso.cn/) for structure predictions (refer to HTC tag `sort_structure` below)**

------------------------------------------
</br>


## Terminologies we used
We adopt the terminologies below from pymatgen and atomate:
  
* firetask - A Firetask is an atomic computing job. For example:
  * copy, move, remove files  
  * prepare VASP input files based on pymatgen
  * modify INCAR
  * modify KPOINTS
  * modify POSCAR
  * submit VASP jobs
  * submit or kill VASP jobs
  * fix some common errors, i.e. ionic divergence, electronic divergence, positive energy.
* firework - A firework is a series of firetaks. Normally, it is composed of three types of firetasks w.r.t the VASP calculation
  * pre-process: setup VASP input files.
      * They can be copied or moved from previous step calucations.
      * They can be generated by pymatgen from scratch.
      * Once VASP input files are prepared via either ways above, they need to be modified so that they are finally appropriate for the target VASP calculation.
  * post-process: actions made after the VASP calculations. *Note that currently, this section is not ready.*
  * job-management: related to job submissions, queries or terminations. **Note that in fact, job submissions, job status queries, or jobs terminations will be realized via signal files (see below). The main jobs for a firework are the pre-process and post-process.**
* workflow - A workflow is a set of fireworks with dependencies between them. For example: 
  * CHGCAR from scf will be required for DOS or band structure calculations.
  * It is common that including dipole corrections likely leads to the electronic divergence. So CHGCAR may be required from a previous calculation without dipole corrections.
  * For [HSE06 calculations](https://cms.mpi.univie.ac.at/vasp/vasp/Typical_hybrid_functional_Hartree_Fock_calculations.html), a preconverged PBE WAVECAR is a good starting point.

You may refer to [atomate](https://hackingmaterials.github.io/atomate/creating_workflows.html#creating-workflows) for more detailed definitions.

-----------------------------------------------
## How to write up HTC\_calculation\_setup\_file  
**We assume the HTC workflow setup is saved into a file named ***HTC\_calculation\_setup\_file***. In addition to structure files, this is the only file that you need to specify to automate the HTC calculations. What follows is how to define a workflow by composing HTC\_calculation\_setup**

* `HTC_calculation_setup` consists of a set of blocks, namely fireworks
* Every firework starts from the line which begins with `**start`, and ends up with the line which begins with `**end`
* In a firework
  * pre-processes and post-processes are defined in a key-value manner with the equal sign `=` linking them. **There is an exception that inside a firework, there is a sub-block related to INCAR modifications. This sub-block starts from the line which begins with `\*begin(add_new_incar_tags)` and it ends with the line which begins with `\*end(add_new_incar_tags)`. In this sub-block, you can overwrite INCAR tags or add new INCAR tags as you are writing INCAR.**
  * In addition, job submissions, job status queries or job terminations will also need to be specified in a key-value manner.
  * Note that **in the first firework**, some job management tags must be set and these setting will be used for the whole workflow:
     * the command to query a job status from a queue system.
     * the command to kill a running job
     * the file which hosts the queue id, say job_id
     * the regular expression to parse the queue id from file job_id using python `re.findall()`
     * tag **vasp.out**.
         * if the job submission cmd in the submission script looks like `mpirun -n 16 vasp_std > out`, then `vasp.out=out`
         * if the job submission cmd in the submission script looks like `mpirun -n 16 vasp_std`, then file vasp.out isn't renamed. So `vasp.out=vasp.out`
     * the prefix and suffix of the stdout file generated by the queue system after the calculation.
     * the prefix and suffix of the stderr file generated by the queue system after the calculation.
     * tag **forece_gamma**: if the kpoints are forced to be gamma-centered.
     * tag **2d_system**: for 2D systems, KPOINTS will be modified so that K\_z is zero for all kpoints.
     * tag **sort_structure**: Whether sort structure or not beforing write POSCAR by the electronegativity of the species 
     * tag **max\_running\_job** and **job\_name**: they decide the maximum number of running/pending jobs.
      
**Please refer to the tag list below for all available HTC tags and their detailed descriptions**

<br>

--------------------------------------------------------------------------------------


## The HTC directory structure  
The directory structure of a HTC is illustrated in the figure below.

* HTC root directory  
	* file `htc_main.py`: the main python file to invoke this HTC program  
	* file `HTC_calculation_setup_file`: a file in which the calculation workflow is defined  
	* folder `Structure folder`: the folder containing those to-be-calculated structures in the cif or POSCAR format. Because this HTC program will apply the pre-defined workflow only to the structures in the folder specified by the HTC tag `structure_folder`, this folder could be anywhere. Putting it into the HTC root directory might be a good choice.  
	* folder `Calculation folder`: The HTC program will read the to-be-calculated structures in `Structure folder` and create a sub-folders for every materials. The sub-folder names would be the same as the associated structure filenames but without extensions. e.g. structure file `Mater_A.cif` will have a corresponding sub-folder named `Mater_A` under `Structure folder`. Similar to `Structure folder`, this folder could be anywhere with the associated HTC tag `cal_folder`, but again putting it into the HTC root directory is a choice.      
		* folder `Mater_A`: The folder corresponding to structure `Mater_A.cif` in `Structure folder`. In this folder, a series of sub-folders will be created for the DFT calculations according to the pre-defined workflow. **Whether the DFT calculations are performed in this folder or in its sub-folders is determined by the HTC tag `sub_dir_cal`**
			* folder `step_1_xxx`: 
				* if `sub_dir_cal=Yes`: a series of sub-folders will be created under this folder. It is in those sub-folders that DFT calculations are carried out. The sub-folder calculations somewhat are fully determined by the command pre-difined by the HTC tag `sub_dir_cal_cmd`
				* if `sub_dir_cal=No`: the DFT calculation pre-defined in the workflow is going to be carried out directly in this folder.
			* folder `step_2_xxx`: 
				* if `sub_dir_cal=Yes`: a series of sub-folders will be created under this folder. It is in those sub-folders that DFT calculations are carried out. The sub-folder calculations somewhat are fully determined by the command pre-defined by the HTC tag `sub_dir_cal_cmd`
				* if `sub_dir_cal=No`: the second DFT calculation pre-defined in the workflow is going to be carried out directly in this folder.
			* ...
		* folder `Mater_B`
			* folder `step_1_xxx`
			* folder `step_2_xxx`
		* ...  


![](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/HTC_directory_structure.png)
</br>

--------------------------------------------------------------------------------------

## Built-in Tag list - below are built-in tags that can be directly used in HTC\_calculation\_setup\_file

- **`{${HTC_CWD}`**: The absolute path to the folder under which `htc_main.py` is  
Any file in `HTC_calculation_setup_file` can be specified by its absolute path or the relative path to `{${HTC_CWD}`  
e.g. Suppose the absolute path ot `htc_main.py` is `/home/user0/htc_cal/htc_main.py` and we need to refer to a file named `file_1` under `/home/user0/htc_cal/folder1/`.  
In this case, `${HTC_CWD}=/home/user0/htc_cal`. `file_1` can be specified using either `/home/user0/htc_cal/folder1/file_1` or `${HTC_CWD}/folder1/file_1`

-------------------------------------



## Tag list - below are tags that can be set in HTC\_calculation\_setup\_file
### (Note that for boolean data type, we use 'Yes' and 'No')
----------------------
![Alt Text](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/VASP_input_file_preparations.png)
</br>
![](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/VASP_input_file_preparations_2.png)


- **structure\_folder** (str), **required for the first firework**  
*The absolute path* of the directory containing to-be-calculated structures. Those to-be-calculated structures could be in the cif format, the VASP POSCAR format or other formats that are supported by `pymatgen.Structure.from_file`.

----------------------

- **cal\_folder** (str), optional for the first firework  
*The absolute path* of the calculation folder. Under this folder, a sub-folder will be created for every to-be-calculated structure. A series of sub-sub-folder will subsequently created for a sequence of VASP calculations.  
Default: `cal_folder= where the htc_main.py is called + \cal_folder`
  
-------------------

- **step\_no** (integer), **required for every firework**.  
start from 1.  
for the n-th firework, step\_no must be n.

------------------------------------------

- **cal\_name** (str), **required for every firework**.  
numbers, alphabets and underscores are valid symbols. *Note that each white space between words will be replaced with an underscore.*  
Together with step\_no, a sub-folder named `step_ + step_no + _ + cal_name` will be created. Under this folder, the VASP calculation will be carried out. e.g. if `step_no=4`, `cal_name=band str`, then the folder name is `step_4_band_str`

-----------------------------

- **copy\_from\_prev\_cal**, optional.  
**This is one way to set up VASP input files.**  
One or more than one files that will be copied from the previous calculation.
*If more than one files are specified, separate them with commas*    
If copy\_which\_step is not set, "the previous calculation" means the *nearest* previous calculation.    
**Note that there is no "the previous calculation" for the first calculation**  
Default: empty

------------------------------

- **move\_from\_prev\_cal**, optional.  
same as copy\_from\_prev\_cal, but those specified files will be moved instead of being copied from the previous firework specified by copy\_which\_step.  
If copy\_which\_step is not set, "the previous firework" is the *nearest* previous firework.   
**Note that there is no "the previous firework" for the first firework**   
Default: empty

----------------------

- **contcar\_to\_poscar** (bool), optional.  
Whether to copy the POSCAR from the previous firework specified by copy\_which\_step and rename it as POSCAR.  
If this tag is `Yes`, the CONTCAR from the previous calculation will be *implicitly* copied and renamed as POSCAR, even though CONTCAR is not in the file list specified by tags copy\_from\_prev\_cal or move\_from\_prev\_cal  
**Note that there is no "the previous firework" for the first firework**  
Default: `No`

--------------------------------

- **copy\_which\_step** (integer), optional.  
This will specify where to copy the files listed in copy\_from\_prev\_cal or move the files listed in move\_from\_prev\_cal.**Note that this tag is meaningless for the first firework**  
**In a workflow, if there are more than one fireworks that depend on the output of the same calculation and are independent of one another, the calculations defined by them will be carried out simultaneously.**  
Default: `step_no-1`

-------------------------------

- **additional\_cal\_dependence**, optional.  
By default, the calculation of the current firework may only rely on the output of its parent firework (specified by `copy_which_step`). However, chances are that the current firework may depend on the outputs of additional previous fireworks. In this case, the current firework shouldn't start unless all dependent previous fireworks are complete.  
`additional_cal_dependence` should be a `step_no` or a array of `step_no`s of the additional dependent fireworks. If an array is given, `step_no` in the array should be separated by commas `,`.     
Example 1: step 3 and step 5 are the self-consistent calculation (provide WAVECAR) and the band structure calculation (provide CBM, VBM, Efermi). In step 6, we want to calculate the associated partial charge density around CBM. In this case, the INCAR setting of step 6 rely on both step 3 and step 5. The corresponding setting should be  
>`copy_which_step=3`
>`additional_cal_dependence=5`   

Example 2: If the raw VASP input setup of step 6 is copied/moved from step 2, and the modification of the input setup of this step also relies on the output of step 3, step 4 and step 5. Then the corresponding setting should be  
>`copy_which_step=2`
>`additional_cal_dependence=3, 4, 5`

Default: `empty` 

---------------------------------

- **remove\_after\_cal**, optional.  
*This tag currently is not available*  
One or more than one files that will be removed after the calculation defined in this firework is complete. If more than one files are specified, separate them via commas.    
***While using this tag, make sure that those specified files will not be needed for later calculations.***    
Default: empty

----------------------------------------

- **extra\_copy**, optional.  
**This tag allows you to prepare VASP input files.**  
This tag allows you to copy files which are not in any previous firework folders.  
*If more than one files are specified, separate them with commas.*  
**The copy action defined by this tag is carried out earlier than the copy/move actions defined by copy\_from\_prev\_cal, move\_from\_prev\_cal. So it is before the modifications on vasp input files.**  
**Note that the absolute path should be provided.**

------------------------------------
	
- **final\_extra\_copy**, optional.  
This tag allows you to copy files which are not in any previous firework folders.  
*If more than one files are specified, separate them with commas.*  
**The copy action defined by this tag is carried out AFTER the modifications on VASP input files.**   
**Note that the absolute path should be provided.**    
  

-------------------------------

- **comment\_incar\_tags**, optional.  ***This tag is already obsolete***  
comment VASP INCAR tags  
*If multiple tags need to be commented, separate them with commas.*  
**It doesn't make sense that you comment an INCAR tag using `comment_incar_tags` while resetting it in `add_new_incar_tags` sub-block simultaneously. If such a contradiction takes place, an error will be incurred.**    
Default: empty

--------------------------

- **remove\_incar\_tags**, optional.  
remove VASP INCAR tags.  
If multiple INCAR tags need to be removed, separate them with commas.  
**It doesn't make sense that you remove an INCAR tag using `remove_incar_tags` while resetting it in `add_new_incar_tags` sub-block simultaneously. If such a contradiction takes place, an error will be incurred.**  
Default: empty

-------------------------------
- **partial\_charge\_cal**, optional.  
This tag enables the partial charge calculation. If this tag is set to `Yes`, the following tags will be automatically added into INCAR of this firework  
>LPARD = .TRUE.  
>NBMOD = -3  
>EINT  = determined by tag `EINT_wrt_CBM` or `EINT_wrt_VBM` and `which_step_to_read_cbm_vbm`


Default: `No`  
**It should be noted that once this tag is set to `Yes`, either `EINT_wrt_CBM` or `EINT_wrt_VBM` should be set in order to determine `EINT`. `which_step_to_read_cbm_vbm` should also be set to read CBM, VBM and Efermi**

--------------------------------------------
- **which\_step\_to\_read\_cbm\_vbm**, optional  
This tag tells us from which previous step CBM, VBM and Efermi can be read in order to determine `EINT` in INCAR if the partial charge calculation is activated.  
Default: `Must be specified in the case where partial charge_cal is set to Yes. No need to set in other cases`  
**It should be noted that `EINT` cannot be determined unless `which_step_to_read_vbm` and one of (`EINT_wrt_CBM`, `EINT_wrt_VBM`) are provided at the same time**  
**CBM, VBM and Efermi are read from the vasprun.xml of the specified previous step. So that vasprun.xml must exist.**


--------------------------------------------
- **EINT\_wrt\_CBM** & **EINT\_wrt\_VBM**, optional    
**either one should be given if `partial_charge_cal=Yes`**  
Default: `Must be specified in the case where partial charge_cal is set to Yes. No need to set in other cases`  
**It should be noted that `EINT` cannot be determined unless `which_step_to_read_vbm` and one of (`EINT_wrt_CBM`, `EINT_wrt_VBM`) are provided at the same time**

-----------------------------------

- **add\_new\_incar\_tags** sub-block, optional
  - start from the line which starts with `*begin(add_new_incar_tags)`; It ends up with the line which starts with `*end(add_new_incar_tags)`
  - In between the starting line and ending line, just specify INCAR tags as if you are writing INCAR:
     - If an INCAR tag is already in the old INCAR, this tag will be overwritten.
     - If an INCAR tag is not in the old INCAR, this tag will be added.  
       
**Note that in this sub-block, the multiple pairs of tag-values separated by `;` in a line is not supported. In this case, only the first pair of tag-value will be parsed as a new INCAR tag, and the value is what is in between the first `=` and the second `=`. This may incur unpredictable errors**   
**Setting multiple pairs of tag-values separated by `;` in a line in INCAR is not supported, either. In this case, an error will be incurred.**

**It doesn't make sense that you reset an INCAR tag in `add_new_incar_tags` sub-block while simultaneously trying to remove this INCAR tag using `remove_incar_tags`. If such a contradiction takes place, an error will be incurred.**  
Default: `empty`  
  ![](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/VASP_specific_calculation.png)

----------------
- **bader\_charge**, optional.
This bool tag decides whether to calculate the [Bader Charge](http://theory.cm.utexas.edu/henkelman/code/bader/). 
	- `Yes`: Calculate the Bader Charge. In this case, those tags will be automatically added into INCAR:  
		- `LCHARG = .TRUE.  
		- LAECHG=.TRUE.  
		- NGXF = 2 * default value  
		- NGYF = 2 * default value  
		- NGZF = 2 * default value`
	- `No`: Don't calculate the Bader Charge.  
Default: `bader_charge=No`  
  
**Where to find default (NGXF, NGYF, NGZF):**  
	- if the current firework is the first step (no parent firework), a calculation without these tags will be carried out and then be terminated once the default values of (NGXF, NGYF, NFZF) are found in the OUTCAR. Afterwards, add all of the associated tags into INCAR for the Bader Charge calculation  
	- if the current firework is not the first step, (NGXF, NGYF, NGZF) will be retrieved from the OUTCAR of the previous calculation which is indicated by `copy_which_step` 

---------------------------------------------------
- **ldau\_cal**, optional.  
Invoke a LDA+U calculation. Note that you need to provide a file containing the Hubbard U and J for the atomic species to which the on-site interaction need to be added. Such file is specified by tag `ldau_u_j_table`.  
Default: `ldau_cal=No`

--------------------------------------------------
- **ldau\_u\_j\_table**, required if `ldau_cal=Yes`  
A file containing the Hubbard U and J for the atomic species to which the on-site interaction need to be added.  
The format of the file:  
`LDAUTYPE=1 | 2 | 4` should be specified in the first line to indicate which type of LDA+U is used. For the following lines, there are four columns, namely, `atomic species`, `orbital type`, `U`, `J`. Bellow is an example of the file:  
>LDAUTYPE = 2  
\#element   orbital_type     U     J  
Sc		    d				2.11	0  
Ti			d				2.58	0  
V			d				2.72	0  
Cr			d				2.79	0  
Mn			d				3.06	0  
  
**Note that U, J and LDAUTYPE may vary, depending on the systems in which you are interested. So we don't provide default values.** 
---------------------------------------------------

- **incar\_template** (`str`), optional for the first firework  
This tag comes into play if you want to order INCAR tags when writing INCAR. `incar_template` refers to a file of which each line is either an INCAR tag or empty. Comments (starting with `#`) will be skipped.  
If this tag is set, INCAR tags will be written into INCAR in the same order/sequence as that in the referred file. The INCAR tags that don't appear in the referred file will be appended to INCAR alphabetically. 
Suppose we have the referred file like below:
>SYSTEM
>
>ENCUT  
ISMEAR  
SIGMA  
EDIFF       
>           
>ISPIN  
>
>IBRION  
ISIF  
EDIFFG  

If We need to write the above tags into an INCAR except `ISPIN` and there are two more tags (e.g. `NPAR` and `ICHARG`), the output INCAR will be similar to what is shown below:  
 
>SYSTEM
>
>ENCUT  
ISMEAR  
SIGMA  
EDIFF       
>            
>
>IBRION  
ISIF  
EDIFFG  
>  
>ICHARG  
NPAR

  
  
-----------------------------------------------------------------------

- **valid\_incar\_tags** (`str`), optional for the first firework  
This tag refers to a file of which each line is a incar tag. Comments (starting with `#`) will be skipped. We call these incar tags appearing in the referred file **valid incar tags**. *Everytime when INCAR is written, the program will check if all incar tags are **valid**. If any incar tag is found invalid， the program will stop and raise an error prompt*  
*This is usefull to avoid unpredictable incar tags due to automatic error corrections or any spelling mistake due to manual modifications*  
*If this tag isn't set or the referred file is empty, nothing will be done*  


----------------------------
![](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/VASP_kpoints_type_1.png)
![](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/VASP_kpoints_type_II.png)
![](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/VASP_kpoints_type_III.png)
--------------------------------------
- **kpoints\_type**, **case sensitive**, **required for every firework**  
options - MPRelaxSet, MPStaticSet, MPNonSCFSet\_line, MPNonSCFSet\_uniform, Line-mode:
  - MPRelaxSet: The KPOINTS generated by pymatgen.io.vasp.sets.MPRelaxSet
  - MPStaticSet: The KPOINTS generated by pymatgen.io.vasp.sets.MPStaticSet
  - MPNonSCFSet\_line: The KPOINTS generated by pymatgen.io.vasp.sets.MPNonSCFSet in the line mode --> In pymatgen, this type of KPOINTS is for band structure calculations
  - MPNonSCFSet\_uniform: The KPOINTS generated by pymatgen.io.vasp.sets.MPNonSCFSet in the uniform mode --> In pymatgen, this type of KPOINTS is for DOS calculations.
  - Line-mode： The KPOINTS in the line mode is written in the reciprocal coordinates for the band structure calculations. The high-symmetry kpoints is decided by [pymatgen.symmetry.bandstructure.HighSymmKpath](http://pymatgen.org/_modules/pymatgen/symmetry/bandstructure.html)


This tag has three functions:
  
   1. After extra\_copy, copy\_from\_prev\_cal or move\_from\_prev\_cal, if there is still no file KPOINTS under the current firework folder, KPOINTS will be created according to kpoints\_type.   
   2. If tag `2d_system` is `Yes`, the KPOINTS will be modified so that K\_z is zero for all kpoints. *Note that this function will be only invoked if KPOINTS under the current firework folder is created. If KPOINTS is copied or moved here from any previous calculations, KPOINTS is then assumed to have zero K\_z for all kpoints.*  
   3. Tag `denser_kpoints` is only valid for the KPOINTS generated at kpoints\_type = MPRelaxSet, MPStaticSet.    

--------------------------------------

- **denser\_kpoints** (three float numbers), optional.  
This tag is only valid for the KPOINTS generated at kpoints\_type = MPRelaxSet, MPStaticSet.  
Suppose the divisions in the reciprocal space are nk_x, nk_y, nk_z and `denser_kpoints` is set to `mx, my, mz`, then the new divsions are `int(nk_x*mx), int(nk_y*my), int(nk_z*mz)`  
*Separate the three numbers with commas.*  
Default: `1, 1, 1`

---------------------------------------------------------
- **reciprocal\_density** (integer), optional.  
This tag is only valid at kpoints\_type=MPNonSCFSet\_uniform  
Default: `1000` <--- the value adopted by atomate's firework NonSCFFW

-----------------------------------------------------------------------
- **kpoints\_line\_density** (integer), optional.  
This tag is only valid at kpoints_type=MPNonSCFSet\_line  
Default: `40` <-- the default value for atomate's firework NonSCFFW is 20

---------------------------------
	
- **intersections** (integer), optional.  
This tag is only valid at kpoints_type=Line-mode.  
**intersections** is the number of equally spaced kpoints between the starting and ending kpoints of every segment of the overall kpath, inclusive of the starting and ending kpoints.  
Default: `20`

-----------------------------
- **force\_gamma**, optional.  
This tag can be set only in the first firework and *this setting will be applied to the whole workflow.*
  - `Yes`: force the kpoints to be gamma-cented.
  - `No`: no such kind of constraint.  
  - Default: `No`

-----------------
- **2d\_system**, optional  
**This tag can be set only in the first firework and this setting will be applied to the whole workflow.**
  - `Yes`: modify kpoints such that K_z is zero for all kpoints.
  - `No`: no such modification on kpoints.
  - Default: `No`
 
----------------------------------
	
- **sort\_structure**, **optional for the first firework**.  
**This tag is activated once POSCAR is written for any firework.**
  - `Yes`: Sort sites by the electronegativity of the atomic species using [`pymatgen.Structure.get_sorted_structure`](http://pymatgen.org/_modules/pymatgen/core/structure.html).
  - `No`: If the given structure is POSCAR-formated, just copy the structure and rename it as POSCAR; If not, write POSCAR using `pymatgen.Structure` without re-ordering atom sites.
  - Default: `Yes`  


***Why do we need this tag?***
  
  * In some cases, the atomic sites may be ordered carefully for some specific purposes. So you may not want to change the order of atoms by pymatgen
  * The `Yes` state of this tag aims to deal with the given structures whose atoms are not grouped by atomic species. For example, the atoms of the given MoS2 may be arranged like `S  Mo  S` instead of `S S  Mo` or `Mo S S`. Such non-grouped atom arrangements may happen if the to-be-calculated structures are outputs of pymatgen and while exporting from pymatgen, `get_sorted_structure` has not been called to group atoms.  
  * The `No` state of this tag can facilitate [split-mode CALYPSO](http://www.calypso.cn/) for structure predictions. By applying the particle swarm optimization method, CALYPSO generates certain number of to-be-relaxed structures. *If CALYPSO works in the split mode, users should **manually** relax these structures.* These structures are POSCAR-formated. Taking into account the backward compatibility of VASP, the line listing atomic species in POSCAR is missing, but `pymatgen.Structure` cannot correctly parse such kind of POSCAR, let alone create correct POSCARs and POTCARs. So we provide this tag `sort_structure` whose `No` mode allows POSCAR to be created by just copying and renaming. With this `No` mode, this VASP HTC framework can be utilized to automatically relax structures predicted by CALYPSO. *Note that since `pymatgen` cannot write correct POTCAR due to the absence of atomic species line in CALYPSO-generated POSCARs, `POTCAR` should be copied from somewhere. This can be realized via tag `extra_copy` or `final_extra_copy`.*   

***The creation of POSCAR:***  
*For the second or later fireworks, POSCAR can be inherited from previous calculations, while this is not the case for the first firework. By default, for the first firework, the program will retrieve the structure under the folder which is specified by tag `structure_folder` where all to-be-calculated structures are stored in the form of cif, POSCAR or others that are supported by `pymatgen.Structure`. Once POSCAR is created according to tag `sort_structure` for the first firework, other VASP input files can be created accordingly and calculations therefore proceed. Of course, you may use tag `user_defined_cmd` to overwrite POSCAR, say cleave surfaces, which is why we let the firetasks defined by `user_defined_cmd` run before the creation of other VASP input files.*

---------------------------------------------
**max\_ionic\_step** (positive integer), optional,  
This tag provides us with another degree of freedom to ensure an accurate structural relaxation.  
**Chances are that a structural relaxation calculation may converge w.r.t `EDIFFG` after N steps, but it will still take tens or hundreds of steps to converge if we change CONTCAR to POSCAR and do one more structural relaxation with the same VASP input setting. In principle, the structural relaxation based on the optimized structure should converge within few steps.**   
If `max_ionic_step` is set, the program will compare the number of step to achieve the ionic convergence, denoted as N, with `max_ionic_step`. If `N>max_ionic_step`, the program will treat the structural relaxation calculation as if the structural relaxation does not converge. The following operations made by the program are to backup the calculation, change CONTCAR to POSCAR, reset `IBRION=1` and re-submit the job. Of course, these automatic operations will be executed only if the number of errors that already happened for the calculation does not reach the specified error maximum above which the error should be handled manually.  
Default `max_ionic_step=-1 (inactive)`  

  
-------------------------------------------
**user\_defined\_cmd**, optional,  
This tag allows users to execute a series of commands to perform user-defined firetasks, say cleave a surface from a bulk structure optimized in the previous firework, introduce dopants/defects *et. al.*  
*If there are multiple commands, separate them with commas.*  
e.g. `user_defined_cmd = date >>__test_file__, echo 'test user_defined_cmd tag' >>__test_file__`    
**By default, the commands will be executed in the current firework folder. You can put your commands in a bash script so that before executing them, you can switch to other folders. If your firetasks involve modifications of VASP input files, we suggest you to make a sub-folder under the current firework folder. Just copy required files into this sub-folder, carry out your firetasks and copy results back, e.g. new POSCAR**  
Default: empty

------------------------

**final\_user\_defined\_cmd**, optional,  
This tag allows users to execute a series of commands to perform user-defined firetasks.  
*If there are multiple commands, separate them with commas.*  
e.g. `final_user_defined_cmd = date >>__test_file__, echo 'test final_user_defined_cmd tag' >>__test_file__`    
**By default, the commands will be executed in the current firework folder. You can put your commands in a bash script so that before executing them, you can switch to other folders. If your firetasks involve modifications of VASP input files, we suggest you to make a sub-folder under the current firework folder. Just copy required files into this sub-folder, carry out your firetasks and copy results back**  
Default: empty

------------------------------------

**user\_defined\_postprocess\_cmd**, optional,  
This tag allows users to execute a series of commands to perform user-defined firetasks for post-process. *This tag is currently not available*  
*If there are multiple commands, separate them with commas.*  
e.g. `user_defined_postprocess_cmd = date >>__test_file__, echo 'test user_defined_postprocess_cmd tag' >>__test_file__`    
**By default, the commands will be executed in the current firework folder. You can put your commands in a bash script so that before executing them, you can switch to other folders. If your firetasks involve modifications of VASP output files, we suggest you to make a sub-folder under the current firework folder in order to avoid damaging VASP output files. Just copy required files into this sub-folder, carry out your firetasks (and copy results back to the current firework folder)**  
Default: empty

-------------------------------------

**sub\_dir\_cal**, optional,  
This tag together with `sub_dir_cal_cmd` defines the sub-folder calculations, as shown in the first figure (the HTC directory structure). See `sub_dir_cal_cmd` for more details about the sub-folder calculations.  
Default: `No`  

------------------------------------

**sub\_dir\_cal\_cmd**, required if `sub_dir_cal=Yes`; optional otherwise,  
This is the main HTC tag to realize sub-folder calculations.  
**Why is there this tag:**  

* Might be useful for the lattice constant optimization for 1D/2D materials if you don't want to use `ISIF=3` to relax everything. Suppose we are gonna relax lattice constant a, we may relax the structure with `ISIF=2` first and then do a single-point calculation with different a. To get the optimal a, we may fit the a v.s. Energy to an equation of state or just make an interpolation.  

**How to realize the sub-folder calculations**  
As shown in the second figure (`The procedure of preparing VASP input files and relevant tags`), actions related to `sub_dir_cal` and `sub_dir_cal_cmd` are taken at the end. So INCAR, POSCAR, KPOINTS and POTCAR have already been prepared according to the preceding HTC tags. **Commands defined by `sub_dir_cal_cmd` should:** 
 
*  use these VASP input files as parent input files, change them as you want, create sub-folders and save them into the sub-folders for sub-folder DFT calculations.
*  create a signal file after the input file preparations in sub-folders such that the HTC program can respond.
	* `__ready__` or `__prior_ready__`: The calculation will be submitted and the signal file will be changed to `__running__`
* change `__sub_dir_cal__` to `__manual__` if any error takes place during the sub-folder input file preparations or in other specified conditions.
* change `__sub_dir_cal__` to `__done__` when all the sub-folder calculations and post-process of the outcome are complete.
* copy some files from sub-folders back to the parent folder such that the subsequent calculations relying on this step can copy required files. **Note that such action may not needed. Those required files can be copied or moved by setting `user_defined_cmd` in the subsequent dependent calculations using relative paths.**  


**commands defined by `sub_dir_cal_cmd` is going to be called repeatedly by the program to detect and change the status of the sub-folder calculation. We suggest you to write all commands into a script and copy that script to the specific calculation folder using HTC tag `extra_copy` or `final_extra_copy`. Then just execute that script.**  

Default: **No default command. Any command that can be executed in the linux terminal. If there are more than one commands, separate them using `,`. Anyway, we suggest you to put all commands into a script and simply run that script.**  

-------------------------------------------------
**preview\_vasp\_inputs**, **optional for the first firework**  
This tag enables you to preview the vasp inputs of each firework defined in `HTC_calculation_setup`. **This tag is designed to check whether the input setting defined in `HTC_calculation_setup` is correct before the real HTC calculation is carried out.**   


- `Yes`: When `python htc_main.py` is executed, a folder named `preview_HTC` will be created under the same directory where `python htc_main.py` is executed. Under `preview_HTC`, the vasp inputs of each firework will be written. ***In this case, the real HTC calculation won't be carried out.***  
- `No`: ***The real HTC calculation will be carried out***  
default: `No`


-----------------------------------------
#### Below are tags related to job managements
-----------------------

- **job\_submission\_script**, **required for every firework**.  
**Note that the absolute path should be used.**

-------------------------------------------------


- **job\_submission\_command**, **required for every firework**.  
e.g. On LSF queue system, suppose the job submission script refered by job\_submission\_script tag is called `vasp.lsf` and this tag can be `bsub < vasp.lsf > job_id`, where `job_id` will store the queue id and will be the value of tag where\_to\_parse\_queue\_id

--------------------------------

- **job\_name**, optional for the first firework.  
The job name shown in the job status query output.  
In PBS queue system, `job_name` is the one specified by the field `#PBS -N "xxx"`  
In LSF queue system, `job_name` is the one specified by the field `#BSUB -J "xxx"`  
where `xxx` in the double quotation marks are `job_name`  
Default: `empty` 

- **max\_running\_job** (integer), optional for the first firework    
The maximum number of running/pending jobs in queue for your htc project. For example, if `max_running_job=10`, the program can automatically submit jobs such that there are maximally 10 running/pending jobs in queue.   
Default: `max_running_job=30`  
**how to count running jobs**  
In general, when you use the cmd specified by `job_query_command` to query the overall status for all submitted jobs, the queue will return a multiple-line summary. Each line of the summary displays the status of a submitted job except the header (the first several lines). The program will count the running/pending jobs of your htc project by counting the string specified by `job_name` in this multiple-line summary. *Note that if the string specified by `job_name` appears more than once in a line, it will be counted as 1.* 

   
**Tips**  
	- If you want `max_running_job` to refer to the total number of running/pending jobs, including those of this htc project and those of other projects, do not set `job_name`. This might be useful if the job submission per user is limited, say every user can submit 20 jobs maximally.  
	- If you want `max_running_job` to refer to the total number of running/pending jobs **only** for this htc project, do set `job_name` and make sure it is unique. This might be useful if there are more than one htc projects, e.g. 20 running/pending jobs for project 1; 30 running/pending jobs for project 2; 5 running/pending jobs for project 3.  
	- If the job submission per user is limited, it is recommended not to set `max_running_job` to that maximal value in case you want to submit some urgent jobs manually. Say each user can submit 30 jobs maximally, `max_running_job=25 or 26 or 27 or 28` might be a good choice.

--------------------

- **where\_to\_parse\_queue\_id**, **required only for the first firework**.  
a file from which the queue id will be parsed.  
e.g. If the job submission cmd is `bsub < vasp.lsf > job_id`, then `where_to_parse_queue_id=job_id`

---------------------

- **re\_to\_parse\_queue\_id**, **required only for the first firework**.  
The regular expression pattern passed to python `re.findall` to parse queue id from the file specified by where\_to\_parse\_queue\_id.  
Just make sure this regular expression is well designed such that no other string in the file where\_to\_parse\_queue\_id can be matched.

----------------------------------

- **job\_query\_command**, **required only for the first firework**.      
For LSF queue system, it is `bjobs -w`   
For PBS queue system, it is `qstat`

---------------------------------------------------------

- **job\_killing\_command**, **required only for the first firework**.  
For LSF queue system, it is `bkill`.    
For PBS queue system, it is `qdel`

--------------------------

- **queue\_stdout\_file\_prefix**, **queue\_stdout\_file\_suffix**, **queue\_stderr\_file\_prefix**, **queue\_stderr\_file\_suffix**, **Required for the first firework**.  
Normally, when the calculation is done, the queue system will generate two files reporting errors and summarizing this work, respectively. Let's denote them as stdout, stderr.  
The two files are useful for their presence indicates that the job is done. If no error is detected for this step, the post-process will proceed and afterwards, the next firework will be carried out. 
 
     **These four tags are set to search for stdout and stderr files.**  
     **Note that you need to specify at least one of the four tags:**  
       - Sometimes the queue stdout and stderr files will join together, giving a single file. In this case, this single file is the target file. You can set its prefix or suffix using either (queue\_stdout\_file\_prefix, queue\_stdout\_file\_suffix) or (queue\_stderr\_file\_prefix, queue\_stderr\_file\_suffix) pair.
       - For either queue stdout or stderr files, it may only have a fixed prefix or a fixed suffix. In this case, you just need to specify the fixed one for the queue file.
         - e.g. for lsf.o1234, just set queue_stdout_file_prefix = lsf.o
         - e.g. for 1234pbs.e, just set queue_stderr_file_suffix = pbs.e
      - **Just make sure the provided suffix or prefix can find the target file(s) stdout or stderr.** 

--------------------------
- **vasp.out**, **required only for the first firework**.  
e.g. If the vasp submission cmd is `mpirun -n 16 vasp_std > out`, then **vasp.out** is `out`  
e.g. If the vasp submission cmd is `mpirun -n 16 vasp_std`, then **vasp.out** is `vasp.out`



-------------
### Tag list ends here. You can find a template of `HTC_calculation_setup_file` under folder `Template`
-------------------------



<br>
<br>
<br>

## How to control job status
### We use signal files to control job submission, job termination, error detection and error correction

![Alt Text](https://github.com/bitsoal/VASP_HTC_framework/blob/master/figs/signal_file_response.PNG)


When the workflow is running, some signal file will be present in every firework folder. The program will respond to these signal files as listed below:
  
- `__vis__`: The program will prepare the vasp input files according to the workflow. Once it is done, `__vis__` --> `__ready__`
- `__ready__`: The program will submit the job by using the command defined in the workflow. Once submitted, `__ready__` --> `__running__`
- `__prior_ready__`: The program will first submit the jobs with this signal file compared to those labeled by `__ready__`
- `__sub_dir_cal__`: This signal file tells the program that a series of calculations are carried out under this folder. HTC tag `sub_dir_cal=Yes` switch `__vis__` to this signal file instead of `__ready__`. This signal file can be changed to `__manual__` or `__done__`, fully depending on the HTC tag `sub_dir_cal_cmd`. Please refer to HTC tags `sub_dir_cal` & `sub_dir_cal_cmd` above for more detail. 
- `__running__`: The program will check the errors on the fly, e.g. check the electronic divergence. If the errors are detected, `__running__` --> `__error__` and write the error type into `__error__`
- `__error__`: The program will kill the job. Once it is done, `__error__` --> `__killed__`
- `__killed__`: The program will try to fix the error. If successful, `__killed__` --> `__ready__`; otherwise `__killed__` --> `__manual__`
- queue system's `stdout` and `stderr`: The program will think the job is done and all error checkers will be called to check errors. If any errors are found, `__running__` --> `__error__`; Otherwise, `__running__` --> `__done__`
- `__manual__`: The program cannot fix the error and the error should be fixed manually.
- `__bad_termination_`: When the job fails due to the error `=   BAD TERMINATION OF ONE OF YOUR APPLICATION PROCESSES` in file vasp.out **for the first time**, the program will **resubmit** the job automatically and create this signal file. When such error happens again, the presence of this signal file tells the program that this is the second time to encounter such error. In this case, the program cannot automatically handle this error anymore, `__killed__` --> `__manual__`.
- `__skipped__`: The jobs labeled by this signal file will be skipped. Users can simply judge if a job is necessary via tag `user_defined_cmd`/`final_user_defined_cmd`. If the calculation is unnecessary, users can generate this signal file to skip unnecessary calculations.

***Signal file priority:*** `__manual__` > `__vis__` > `__skipped__` > `__ready__` > `prior_ready__` > `__sub_dir_cal__` > `__error__` > `__running__` > `__done__` > `__killed__`  




**Note that when you manually fix an error or tune VASP input files under a filework folder, DO remove these signal tags so that the program has nothing to do with this firework folder. After modifications, you have two ways to bring it back to the program scope (_The second way is recommended_):**

- If you want to manually submit the job:
  - step I: remove OUTCAR, OSZICAR, vasp.out, queue stdout & stderr files.
  - step II: submit the job
  - step III: create the signal file `__running__`.
- If you want the program to do the job submission:
	- All you need to do is to create the signal file `__ready__`. In this case, the program will automatically remove OUTCAR, OSZICAR, vasp.out, queue stdout & stderr files before submitting this job.  


### How to stop the program.
You can stop this program by creating a file named `__stop__` under the same directory where `python htc_main.py` or `nohup python htc_main.py 2>1&` was executed to start this program.



