#!/usr/bin/env python
# coding: utf-8

# In[1]:


import os, sys, time

##############################################################################################################
##DO NOT change this part.
##../setup.py will update this variable
HTC_package_path = "C:/Users/tyang/Documents/Jupyter_workspace/HTC/python_3"
assert os.path.isdir(HTC_package_path), "Cannot find this VASP_HTC package under {}".format(HTC_package_path)
if HTC_package_path not in sys.path:
    sys.path.append(HTC_package_path)
##############################################################################################################

#from pathlib import Path
from HTC_lib.VASP.Miscellaneous.Utilities import get_time_str
from HTC_lib.VASP.Miscellaneous.Backup_HTC_input_files import backup_htc_input_files, backup_a_file
from HTC_lib.VASP.Miscellaneous.change_signal_file import change_signal_file
from HTC_lib.VASP.Miscellaneous.Cal_status_dictionary_operation import Cal_status_dict_operation

from HTC_lib.VASP.Preprocess_and_Postprocess.Parse_calculation_workflow import parse_calculation_workflow
from HTC_lib.VASP.Preprocess_and_Postprocess.new_Preprocess_and_Postprocess import pre_and_post_process
from HTC_lib.VASP.Job_Management.Check_and_update_calculation_status import check_calculations_status, update_job_status
from HTC_lib.VASP.Job_Management.Submit_and_Kill_job import submit_jobs

from concurrent.futures import ProcessPoolExecutor


# In[2]:


def read_workflow():
    workflow = []
    if os.path.isfile("HTC_calculation_setup_file"):
        workflow.append(parse_calculation_workflow("HTC_calculation_setup_file", HTC_lib_loc=HTC_package_path))
    if os.path.isdir("HTC_calculation_setup_folder"):
        workflow.append(parse_calculation_workflow("HTC_calculation_setup_folder", HTC_lib_loc=HTC_package_path))
    
    if workflow == []:
        raise Exception("Error: No HTC_calculation_setup_file or HTC_calculation_setup_folder under {}".format(os.getcwd()))
    elif len(workflow) == 1:
        workflow = workflow[0]
    else:
        for wf_ind in range(len(workflow[0])):
            assert workflow[0][wf_ind] == workflow[1][wf_ind], "Error: the {}st|nd|th firework/calculation setup parsed from 'HTC_calculation_setup_file' is not identical to that from 'HTC_calculation_setup_folder'".format(wf_ind+1)
        workflow = workflow[0]
        
    return workflow


# In[3]:


def backup_htc_files(workflow):
    htc_input_backup_loc = workflow[0]["htc_input_backup_loc"]
    other_htc_inputs = ["htc_main.py"] + list(workflow[0]["htc_input_backup"])
    if os.path.isfile("HTC_calculation_setup_file"):
        backup_a_file(src_folder=".", src_file="HTC_calculation_setup_file", dst_folder=htc_input_backup_loc, overwrite=False)
    else:
        other_htc_inputs.append("HTC_calculation_setup_folder")
    backup_htc_input_files(src_folder=".", file_or_folder_list=other_htc_inputs, dst_folder=htc_input_backup_loc)    


# In[4]:


def handle_stop_update_now_n_change_signal_file(signal_file_path, total_cal_status=None):
   """
   This function wraps up the responses to __stop__, __update_now__ and __change_signal_file__ present under main_dir.
   input arguments:
       * signal_file_path: the absolute path of the above signal file
       * total_cal_status (default: None): a dict generated by function check_calculations_status 
   return:
       * for __stop__, the return is True, a signal to terminate this htc program.
       * for __update_now__, the return is True
       * for __change_signal_file__, the return is the updated total_cal_status.
   """
   signal_file = os.path.split(signal_file_path)[1]
   assert signal_file in ["__stop__", "__update_now__", "__change_signal_file__"], "Input argument signal_file_path must end  with '__stop__', '__update_now__' or '__change_signal_file__'. But now it is {}".format(signal_file_path)
   
   if signal_file == "__stop__":
       if os.path.isfile(signal_file_path):
           print(">>>{}: detected file __stop__ in HTC_CWD \n ---->stop this program in this process.".format(get_time_str()),flush=True)
           return True
       else:
           return False
   
   if signal_file == "__update_now__" and os.path.isfile(signal_file_path):
       os.remove(signal_file_path)
       print("{}: removed __update_now__".format(get_time_str()), flush=True)
       return False
   
   if signal_file == "__change_signal_file__":
       if os.path.isfile(signal_file_path):
           total_cal_status = change_signal_file(total_cal_status, signal_file_path)
           os.remove(change_signal_file_path)
           print("{}: removed __change_signal_file__".format(get_time_str()), flush=True)
       return total_cal_status


# In[5]:


if __name__ == "__main__":
           
    main_dir = os.getcwd()
    stop_file_path = os.path.join(main_dir, "__stop__")
    htc_job_status_file_path = os.path.join(main_dir, "htc_job_status.json")
    update_now_file_path = os.path.join(main_dir, "__update_now__")
    change_signal_file_path = os.path.join(main_dir, "__change_signal_file__")
    update_input_file_path = os.path.join(main_dir, "__update_input__")
    go_to_sub_signal_file_path = os.path.join(main_dir, "__go_to_submission__")
    scan_all_file_path = os.path.join(main_dir, "__scan_all__")
    forced_sleep_file_path = os.path.join(main_dir, "__forced_sleep__")
    
    signal_file_list = ["__stop__", "__update_now__", "__update_input__", "__change_signal_file__", 
                        "__go_to_submission__", "__scan_all__"]
    
    open(scan_all_file_path, "w").close() 
    output_str = "{}: created __scan_all__ to ask the program to scan the status of all calculations.\n".format(get_time_str())
    output_str += "\tLater scanning only involves those calculations which are automatically updated by the program.\n"
    output_str += "\tIf you manually changed some calculations' status, you need to create __scan_all__ to obtain all of these manually updated calculations' status"
    print(output_str, flush=True)
    
    print("{}: reading the pre-defined calculation workflow".format(get_time_str()), flush=True)
    workflow = read_workflow()
    structure_file_folder = workflow[0]["structure_folder"]
    cal_folder = workflow[0]["cal_folder"]
    max_workers = workflow[0]["max_workers"]
    assert isinstance(max_workers, int), "Since you are trying to deploy ProcessPoolExecutor for parallel computing, 'max_workers' should be provided in the first step and should be a positive integer."
    print("{}: finished reading the pre-defined calculation workflow".format(get_time_str()), flush=True)
    if not os.path.isdir(cal_folder):
        os.mkdir(cal_folder)
    
    print("{}: starts to backup htc files".format(get_time_str()), flush=True)
    try:
        backup_htc_files(workflow=workflow)
    except Exception as e:
        print("{}: An error below is encountered while the program is trying to backup htc files.".format(get_time_str()), flush=True)
        print(e)
    print("{}: finishes the backup of htc files".format(get_time_str()), flush=True)
        
    print("{}: entering the while loop.".format(get_time_str()), flush=True)
    while_loop_period = 600 #seconds
    no_of_same_cal_status, total_cal_status_0 = 0, {}
    while True:
        while_loop_t0 = time.time()
        
        ##############################################################
        #read the updated pre-defined calculation workflow
        while os.path.isfile(update_input_file_path):
            print("{}: __update_input__ is found in HTC_CWD. Read the updated pre-defined calculation workflow".format(get_time_str()), flush=True)
            workflow = read_workflow()
            os.remove(update_input_file_path)
            print("{}: Finished & Removed __update_input__".format(get_time_str()), flush=True)
            
            is_forced_sleep, output_str = False, ""
            if structure_file_folder != workflow[0]["structure_folder"]:
                output_str += "\n{} To be confirmed: I notice that you've changed 'structure_folder' in the updated pre-defined calculation workflow.".format(get_time_str())
                output_str += "\n\told: {}\n\tnew: {}".format(structure_file_folder, workflow[0]["structure_folder"])
                is_forced_sleep = True
            if cal_folder != workflow[0]["cal_folder"]:
                output_str += "\n{} To be confirmed: I notice that you've changed 'cal_folder' in the updated pre-defined calculation workflow.".format(get_time_str())
                output_str += "\n\told: {}\n\tnew: {}".format(cal_folder, workflow[0]["cal_folder"])
                is_forced_sleep = True
            if is_forced_sleep:
                output_str += "\n\t__forced_sleep__ is created to wait for you to confirm."
                output_str += "\n\tIf this is what you want, remove __forced_sleep__ to proceed. Otherwise, follow the below steps to update pre-defined calculation workflow AGAIN."
                output_str += "\n\t\tstep 1. update pre-defined calculation workflow\n\t\tstep 2. create __update_input__\n\tstep 3. remove __forced_sleep__"
                print(output_str, flush=True)
                open(forced_sleep_file_path, "w").close()
            while os.path.isfile(forced_sleep_file_path): 
                os.sleep(10)
            if not os.path.isfile(update_input_file_path):
                structure_file_folder = workflow[0]["structure_folder"]
                cal_folder = workflow[0]["cal_folder"]    
                if not os.path.isdir(cal_folder):
                    os.mkdir(cal_folder)
                print("{}: You have confirmed the above change(s). Let's proceed to create __scan_all__".format(get_time_str()), flush=True)
                open(scan_all_file_path, "w").close()
            
            max_workers = workflow[0]["max_workers"]
            assert isinstance(max_workers, int), "Since you are trying to deploy ProcessPoolExecutor for parallel computing, 'max_workers' should be provided in the first step and should be a positive integer."
        #finish the updated pre-defined calculation workflow
        ##############################################################
        
        #Handle signal file __stop__ and __update_now__ if existent
        if handle_stop_update_now_n_change_signal_file(signal_file_path=stop_file_path): break
        handle_stop_update_now_n_change_signal_file(signal_file_path=update_now_file_path)
            
        ##############################################################
        ##Start of "Update calculation status"
        if os.path.isfile(scan_all_file_path):
            print("{}: __scan_all__ is detected. Start scanning all folders under {}".format(get_time_str(), main_dir), flush=True)
            mat_folder_name_list = [[mat_folder_name] for mat_folder_name in os.listdir(cal_folder)] #os.listdir excludes entry '.'
            length = len(mat_folder_name_list)
            cal_folder_list, workflow_list = [cal_folder] * length, [workflow] * length
            with ProcessPoolExecutor(max_workers=max_workers) as executor:
                cal_status_dict_list = list(executor.map(check_calculations_status, cal_folder_list, workflow_list, mat_folder_name_list))
            del mat_folder_name_list, cal_folder_list, workflow_list, length
            total_cal_status = Cal_status_dict_operation.merge_dicts(a_list_of_dicts=cal_status_dict_list)
            for tag in ["ready_folder_list", "prior_ready_folder_list"]:
                if tag not in total_cal_status.keys():
                    total_cal_status[tag] = []
            Cal_status_dict_operation.write_cal_status(cal_status=total_cal_status, filename=htc_job_status_file_path)
            os.remove(scan_all_file_path)
            print("{}: removed __scan_all__".format(get_time_str()), flush=True)
        
        if os.path.isfile(scan_all_file_path) or os.path.isfile(go_to_sub_signal_file_path) or os.path.isfile(update_input_file_path):
            print("{}: __scan_all__, __go_to_submission__ or __update_input__ is detected under HTC_CWD. Skip job status update.".format(get_time_str()), flush=True)
        else:
            #In the for loop below, swift response to signal files under HTC_CWD/main_dir has been handled properly within function update_job_status
            for which_status in Cal_status_dict_operation.get_to_be_updated_status_list(total_cal_status):
                print("{}: starts updating {}".format(get_time_str(), which_status), flush=True)
                if which_status not in  total_cal_status.keys():
                    continue
                if which_status == "running_folder_list":
                    #In this case, we put the ProcessPoolExecutor based parallization into function update_job_status.
                    #As such, the defined job_query_command will be just called ONCE to take care of all to-be-updated jobs originally tagged by __running__.
                    #If the below else clause is adopted, job_query_command will be repeatedly called - One call each job. That's a very intensive request for the job scheduler.
                    total_cal_status_diff = update_job_status(cal_folder=cal_folder, workflow=workflow, which_status=which_status, job_list=total_cal_status[which_status])
                else:
                    job_list = [[job] for job in total_cal_status[which_status]]
                    length = len(job_list)             
                    cal_folder_list, workflow_list, which_status_list = [cal_folder] * length, [workflow] * length, [which_status] * length
                    with ProcessPoolExecutor(max_workers=max_workers) as executor:
                        cal_status_diff_dict_list = list(executor.map(update_job_status, cal_folder_list, workflow_list, which_status_list, job_list))
                    total_cal_status_diff = Cal_status_dict_operation.merge_cal_status_diff(a_list_of_cal_status_diff=cal_status_diff_dict_list)
                    del cal_folder_list, workflow_list, which_status_list, length, job_list
                total_cal_status = Cal_status_dict_operation.update_old_cal_status_dict(old_cal_status_dict=total_cal_status, cal_status_dict_diff=total_cal_status_diff)
                
                is_signal_file_found = False
                for file in os.listdir(main_dir):
                    if file in signal_file_list:
                        print("{}: {} is detected under HTC_CWD. Stop updating {} jobs' status.".format(get_time_str(), file, which_status), flush=True)
                        is_signal_file_found = True
                        break
                if is_signal_file_found:
                    break
                        
                print("{}: finished update of {}".format(get_time_str(), which_status), flush=True)
            Cal_status_dict_operation.write_cal_status(cal_status=total_cal_status, filename=htc_job_status_file_path)
        ##END of "Update calculation status"
        #########################################################################
          
        #Handle signal file __stop__, __update_now__ and __change_signal_file__ if existent
        if handle_stop_update_now_n_change_signal_file(signal_file_path=stop_file_path): break
        handle_stop_update_now_n_change_signal_file(signal_file_path=update_now_file_path)
        if not os.path.isfile(scan_all_file_path):
            total_cal_status = handle_stop_update_now_n_change_signal_file(signal_file_path=change_signal_file_path, total_cal_status=total_cal_status)
            Cal_status_dict_operation.write_cal_status(cal_status=total_cal_status, filename=htc_job_status_file_path)
            
        #########################################################################
        ##Start of "Prepare VASP input files"   
        if os.path.isfile(scan_all_file_path) or os.path.isfile(go_to_sub_signal_file_path) or os.path.isfile(update_input_file_path):
            print("{}: __scan_all__, __go_to_submission__ or __update_input__ is detected under HTC_CWD. Skip vasp input file preparation.".format(get_time_str()), flush=True)
        else:
            structure_file_list = os.listdir(structure_file_folder)
            group_size = max_workers * 2
            max_group_ind = int(len(structure_file_list) / group_size) + 1
            max_no_of_ready_jobs = workflow[0]["max_no_of_ready_jobs"] - len(total_cal_status["ready_folder_list"]) - len(total_cal_status["prior_ready_folder_list"])
            for group_ind in range(max_group_ind+1):
                structure_file_sublist = structure_file_list[group_ind*group_size:(group_ind+1)*group_size]
                length = len(structure_file_sublist)
                structure_file_folder_list, cal_folder_list, workflow_list = [structure_file_folder]*length, [cal_folder]*length, [workflow]*length
                with ProcessPoolExecutor(max_workers=max_workers) as executor:
                    output = executor.map(pre_and_post_process, structure_file_sublist, structure_file_folder_list, cal_folder_list, workflow_list)
                    cal_status_dict_diff_list = []
                    for no_of_new_ready_jobs, cal_status_dict_diff in output:
                        max_no_of_ready_jobs -= no_of_new_ready_jobs
                        cal_status_dict_diff_list.append(cal_status_dict_diff)
                del length, structure_file_folder_list, cal_folder_list, workflow_list
                total_cal_status_diff = Cal_status_dict_operation.merge_cal_status_diff(a_list_of_cal_status_diff=cal_status_dict_diff_list)
                total_cal_status = Cal_status_dict_operation.update_old_cal_status_dict(old_cal_status_dict=total_cal_status, cal_status_dict_diff=total_cal_status_diff)
                print("{}: finished input preparation for {}".format(get_time_str(), ", ".join(structure_file_sublist)), flush=True)
                
                if max_no_of_ready_jobs <= 0:
                    break
                is_signal_file_found = False
                for file in os.listdir(main_dir):
                    if file in signal_file_list:
                        print("{}: {} is detected under HTC_CWD. Stop preparation of VASP input files".format(get_time_str(), file), flush=True)
                        is_signal_file_found = True
                        break
                if is_signal_file_found:
                    break
                del is_signal_file_found
                        
            Cal_status_dict_operation.write_cal_status(cal_status=total_cal_status, filename=htc_job_status_file_path)
            print("{}: finished input file preparation".format(get_time_str()), flush=True)
            # END of "Prepare VASP input files"
        ###############################################################################
        
        #Handle signal file __stop__, __update_now__ and __change_signal_file__ if existent
        if handle_stop_update_now_n_change_signal_file(signal_file_path=stop_file_path): break
        handle_stop_update_now_n_change_signal_file(signal_file_path=update_now_file_path)
        if os.path.isfile(scan_all_file_path):
            total_cal_status = handle_stop_update_now_n_change_signal_file(signal_file_path=change_signal_file_path, total_cal_status=total_cal_status)
            Cal_status_dict_operation.write_cal_status(cal_status=total_cal_status, filename=htc_job_status_file_path)
            
        ###############################################################################
        ##Start of "Job submission"
        if os.path.isfile(scan_all_file_path) or os.path.isfile(update_input_file_path):
            print("{}: __scan_all__ or __update_input__ is detected under HTC_CWD. Skip job status update.".format(get_time_str()), flush=True)
        else:
            if os.path.isfile(go_to_sub_signal_file_path): 
                os.remove(go_to_sub_signal_file_path)
                print("{}: reach the job submission section. removed __go_to_submission__".format(get_time_str()), flush=True)
            print("{}: starts submitting ready jobs".format(get_time_str()), flush=True)
            
            #submit jobs.
            submitted_job_list = submit_jobs(cal_jobs_status=total_cal_status, workflow=workflow, max_jobs_in_queue=workflow[0]["max_running_job"])
            
            #update the status of the submitted jobs
            length = len(submitted_job_list)
            cal_folder_list, workflow_list, mat_folder_name_list = [cal_folder] * length, [workflow] * length, [None] * length
            submitted_job_list = [[job] for job in submitted_job_list]
            with ProcessPoolExecutor(max_workers=max_workers) as executor:
                cal_status_list = list(executor.map(check_calculations_status, cal_folder_list, workflow_list, mat_folder_name_list, submitted_job_list))
            del submitted_job_list, length, cal_folder_list, workflow_list, mat_folder_name_list
            new_cal_status = Cal_status_dict_operation.merge_dicts(cal_status_list)
            pseudo_old_cal_status = check_calculations_status(cal_folder=cal_folder, workflow=workflow, cal_loc_list=[])
            cal_status_diff = Cal_status_dict_operation.diff_status_dict(old_cal_status_dict=pseudo_old_cal_status, new_cal_status_dict=new_cal_status)
            total_cal_status = Cal_status_dict_operation.update_old_cal_status_dict(old_cal_status_dict=total_cal_status, cal_status_dict_diff=cal_status_diff)
            Cal_status_dict_operation.write_cal_status(cal_status=total_cal_status, filename=htc_job_status_file_path)
    
            print("{}: completed job submission.".format(get_time_str()), flush=True)
        ##END of "Job submission"
        ###############################################################################
            
        #Handle signal file __stop__, __update_now__ and __change_signal_file__ if existent
        if handle_stop_update_now_n_change_signal_file(signal_file_path=stop_file_path): break
        handle_stop_update_now_n_change_signal_file(signal_file_path=update_now_file_path)
        if not os.path.isfile(scan_all_file_path):
            total_cal_status = handle_stop_update_now_n_change_signal_file(signal_file_path=change_signal_file_path, total_cal_status=total_cal_status)
            Cal_status_dict_operation.write_cal_status(cal_status=total_cal_status, filename=htc_job_status_file_path)
            
        ################################################################################
        #check if all calculations are complete. If this is the case, stop. At the end, all calculations should be labeled by signal file __done__, __skipped__, and __done_cleaned_analyzed__
        no_of_ongoing_jobs = sum([len(job_list) for job_status, job_list in total_cal_status.items() if job_status not in ["done_folder_list", "skipped_folder_list", "done_cleaned_analyzed_folder_list"]])
        if no_of_ongoing_jobs == 0:
            output_str = "{}: all calculations have finished, i.e. all calculations are labelled by __done__, __skipped__, and __done_cleaned_analyzed__ only --> Stop this program.".format(get_time_str())
            print(output_str, flush=True)
            with open(htc_job_status_file_path, "a") as f:
                f.write("\n***" + output_str + "***")
            break
        
        #If total_cal_status is unchanged for the 200 consecutive scannings, also stop.
        if total_cal_status == total_cal_status_0:
            no_of_same_cal_status += 1
        else:
            total_cal_status_0 = total_cal_status
            no_of_same_cal_status = 0
        if no_of_same_cal_status == 200:
            output_str = "{}: All jobs' statuses remain unchanged for a long time. Stop this program.".format(get_time_str())
            with open(htc_job_status_file_path, "a") as f:
                f.write("\n***{}***".format(output_str))
            print(output_str, flush=True)
            break
        else:
            print("{}: Some jobs' statuses are still updating. --> HTC is ongoing.".format(get_time_str()), flush=True)
        #END of the checkup 
        ################################################################################
        
        ################################################################################
        #Start of sleep
        while (time.time() - while_loop_t0) < while_loop_period:
            if any([file in signal_file_list for file in os.listdir(main_dir)]):
                break
            else:
                time.sleep(10)
            while os.path.isfile(os.path.join(main_dir, "__forced_sleep__")):
                time.sleep(10) 
        while_loop_t0 = time.time()
        #End of sleep
        ################################################################################

        #Handle signal file __stop__, __update_now__ and __change_signal_file__ if existent
        if handle_stop_update_now_n_change_signal_file(signal_file_path=stop_file_path): break
        handle_stop_update_now_n_change_signal_file(signal_file_path=update_now_file_path)
        if not os.path.isfile(scan_all_file_path):
            total_cal_status = handle_stop_update_now_n_change_signal_file(signal_file_path=change_signal_file_path, total_cal_status=total_cal_status)
            Cal_status_dict_operation.write_cal_status(cal_status=total_cal_status, filename=htc_job_status_file_path)
            
        print("\n{}: ***Arrives at the end of the while loop. Will enter the next round of iteration.***\n".format(get_time_str()), flush=True)

